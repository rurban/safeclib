<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>safec: safe_str_lib.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">safec
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">Safe C Library - ISO TR24731 Bounds Checking Interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/dff/safe__str__lib_8h.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">safe_str_lib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../d3/ddb/safe__config_8h.html">safe_config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d0/dc2/safe__lib__errno_8h.html">safe_lib_errno.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dd/d0a/safe__types_8h.html">safe_types.h</a>&quot;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;wchar.h&gt;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Include dependency graph for safe_str_lib.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="../../d4/d1f/safe__str__lib_8h__incl.png" border="0" usemap="#safe__str__lib_8h" alt=""/></div>
<map name="safe__str__lib_8h" id="safe__str__lib_8h">
<area shape="rect" id="node2" href="../../d3/ddb/safe__config_8h.html" title="safe_config.h" alt="" coords="5,80,87,107"/>
<area shape="rect" id="node3" href="../../d0/dc2/safe__lib__errno_8h.html" title="safe_lib_errno.h" alt="" coords="111,80,205,107"/>
<area shape="rect" id="node5" href="../../dd/d0a/safe__types_8h.html" title="safe_types.h" alt="" coords="229,80,308,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a77366c1bd428629dc898e188bfd182a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a>&#160;&#160;&#160;extern</td></tr>
<tr class="separator:a77366c1bd428629dc898e188bfd182a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848ae7e999628921f4b96fc11e1c4005"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a848ae7e999628921f4b96fc11e1c4005">RSIZE_MIN_STR</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:a848ae7e999628921f4b96fc11e1c4005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37c2dfd05a44edf71ed743e1fb65d36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#af37c2dfd05a44edf71ed743e1fb65d36">RSIZE_MAX_WSTR</a>&#160;&#160;&#160;( <a class="el" href="../../d3/ddb/safe__config_8h.html#a05ab44a94e05e033959f296e9b2796fc">RSIZE_MAX_STR</a>/sizeof(wchar_t) )</td></tr>
<tr class="separator:af37c2dfd05a44edf71ed743e1fb65d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df79107e349c3cbe5843e22549ffe9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a5df79107e349c3cbe5843e22549ffe9d">SAFE_STR_MIN_LOWERCASE</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:a5df79107e349c3cbe5843e22549ffe9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd55d8f01e69e8764baa2cacddd1e0c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#acd55d8f01e69e8764baa2cacddd1e0c0">SAFE_STR_MIN_UPPERCASE</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:acd55d8f01e69e8764baa2cacddd1e0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1b167253e62ad73e919e706f2881a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a1b1b167253e62ad73e919e706f2881a1">SAFE_STR_MIN_NUMBERS</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:a1b1b167253e62ad73e919e706f2881a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a88d55101f78c306eff57eeb5e96f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa2a88d55101f78c306eff57eeb5e96f5">SAFE_STR_MIN_SPECIALS</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:aa2a88d55101f78c306eff57eeb5e96f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad5ec9e1933bab308f8157d8f9b1296"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a1ad5ec9e1933bab308f8157d8f9b1296">SAFE_STR_PASSWORD_MIN_LENGTH</a>&#160;&#160;&#160;( 6 )</td></tr>
<tr class="separator:a1ad5ec9e1933bab308f8157d8f9b1296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dbd49bd0bab60ec22e31f47759bd2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a27dbd49bd0bab60ec22e31f47759bd2a">SAFE_STR_PASSWORD_MAX_LENGTH</a>&#160;&#160;&#160;( 32 )</td></tr>
<tr class="separator:a27dbd49bd0bab60ec22e31f47759bd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3838c5a9d1c42f1794cc142eaaceab1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a3838c5a9d1c42f1794cc142eaaceab1c">sl_default_handler</a>&#160;&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7fdc3594c01813cc1fdf77dc378715de">ignore_handler_s</a></td></tr>
<tr class="separator:a3838c5a9d1c42f1794cc142eaaceab1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ec7c15269eddc82121895650a737a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a680ec7c15269eddc82121895650a737a">strlwr_s</a>(str,  slen)&#160;&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a39d393f60f6de53c22c2285ec379a046">strtolowercase_s</a>((str), (slen))</td></tr>
<tr class="separator:a680ec7c15269eddc82121895650a737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee34569f251b5bb3631aa4e4be522c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aeee34569f251b5bb3631aa4e4be522c7">strupr_s</a>(str,  slen)&#160;&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a38d442591898fb246a2bd5aa590a6921">strtouppercase_s</a>((str), (slen))</td></tr>
<tr class="separator:aeee34569f251b5bb3631aa4e4be522c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7e951343fed5789c4ec0a61bace0b135"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50">wcsnorm_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7e951343fed5789c4ec0a61bace0b135">wcsnorm_mode_t</a></td></tr>
<tr class="separator:a7e951343fed5789c4ec0a61bace0b135"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a697d7515ad4cf3ad48348c7df8ec3a50"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50">wcsnorm_mode</a> { <br />
&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50ae39f2c22080365c283487fea1ad7b28c">WCSNORM_NFD</a> = 0, 
<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50a501e8094ee08cc856acc05eefa75d9df">WCSNORM_NFC</a> = 1, 
<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50af8079f81dd7039ba42c612e75e0a1676">WCSNORM_FCD</a> = 2, 
<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50a2a991639d09c68b33630fce968285acc">WCSNORM_FCC</a> = 3, 
<br />
&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50aec3bda705e086f32ef4b631f59fb5ad7">WCSNORM_NFKD</a> = 4, 
<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50a1ca77d91d24686356b7c7f243d78137e">WCSNORM_NFKC</a> = 5
<br />
 }</td></tr>
<tr class="separator:a697d7515ad4cf3ad48348c7df8ec3a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58587c173fa4c66368d5ba43095d6f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a58587c173fa4c66368d5ba43095d6f72">abort_handler_s</a> (const char *restrict msg, void *restrict ptr, errno_t error)</td></tr>
<tr class="memdesc:a58587c173fa4c66368d5ba43095d6f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a message on the standard error stream in an implementation-defined format.  <a href="#a58587c173fa4c66368d5ba43095d6f72">More...</a><br /></td></tr>
<tr class="separator:a58587c173fa4c66368d5ba43095d6f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc3594c01813cc1fdf77dc378715de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7fdc3594c01813cc1fdf77dc378715de">ignore_handler_s</a> (const char *restrict msg, void *restrict ptr, errno_t error)</td></tr>
<tr class="memdesc:a7fdc3594c01813cc1fdf77dc378715de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function simply returns to the caller.  <a href="#a7fdc3594c01813cc1fdf77dc378715de">More...</a><br /></td></tr>
<tr class="separator:a7fdc3594c01813cc1fdf77dc378715de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0dee168db30fa183ed12b8de14fd0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> <a class="el" href="../../dd/d0a/safe__types_8h.html#a94a54e98967ccb6be4bb4ad7e39fc290">constraint_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aff0dee168db30fa183ed12b8de14fd0b">set_str_constraint_handler_s</a> (<a class="el" href="../../dd/d0a/safe__types_8h.html#a94a54e98967ccb6be4bb4ad7e39fc290">constraint_handler_t</a> handler)</td></tr>
<tr class="memdesc:aff0dee168db30fa183ed12b8de14fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set_str_constraint_handler_s function sets the runtime-constraint handler to be handler.  <a href="#aff0dee168db30fa183ed12b8de14fd0b">More...</a><br /></td></tr>
<tr class="separator:aff0dee168db30fa183ed12b8de14fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24c1a4615dbfb0970303132bb2785e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa24c1a4615dbfb0970303132bb2785e3">strcat_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict src)</td></tr>
<tr class="memdesc:aa24c1a4615dbfb0970303132bb2785e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strcat_s function appends a copy of the string pointed to by src (including the terminating null character) to the end of the string pointed to by dest.  <a href="#aa24c1a4615dbfb0970303132bb2785e3">More...</a><br /></td></tr>
<tr class="separator:aa24c1a4615dbfb0970303132bb2785e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf29ab8687ac8eeeaacf6a577402dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aadf29ab8687ac8eeeaacf6a577402dd2">strcpy_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict src)</td></tr>
<tr class="memdesc:aadf29ab8687ac8eeeaacf6a577402dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strcpy_s function copies the string pointed to by src (including the terminating null character) into the array pointed to by dest.  <a href="#aadf29ab8687ac8eeeaacf6a577402dd2">More...</a><br /></td></tr>
<tr class="separator:aadf29ab8687ac8eeeaacf6a577402dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4975d61777c3b8e60885037bc27b9ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a4975d61777c3b8e60885037bc27b9ab7">strncat_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a4975d61777c3b8e60885037bc27b9ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strncat_s function appends a copy of the string pointed to by src (including the terminating null character) to the end of the string pointed to by dest.  <a href="#a4975d61777c3b8e60885037bc27b9ab7">More...</a><br /></td></tr>
<tr class="separator:a4975d61777c3b8e60885037bc27b9ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa198dc424193180e9bb0a13035c6cf5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa198dc424193180e9bb0a13035c6cf5e">strncpy_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:aa198dc424193180e9bb0a13035c6cf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strncpy_s function copies not more than slen successive characters (characters that follow a null character are not copied) from the array pointed to by src to the array pointed to by dest.  <a href="#aa198dc424193180e9bb0a13035c6cf5e">More...</a><br /></td></tr>
<tr class="separator:aa198dc424193180e9bb0a13035c6cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f0d069d4e184635b159849a1b99183"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a97f0d069d4e184635b159849a1b99183">strnlen_s</a> (const char *s, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> smax)</td></tr>
<tr class="memdesc:a97f0d069d4e184635b159849a1b99183"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strnlen_s function computes the length of the string pointed to by dest.  <a href="#a97f0d069d4e184635b159849a1b99183">More...</a><br /></td></tr>
<tr class="separator:a97f0d069d4e184635b159849a1b99183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de538c8ac877750ba12b2c186fb375a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a3de538c8ac877750ba12b2c186fb375a">strtok_s</a> (char *restrict s1, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict s1max, const char *restrict src, char **restrict ptr)</td></tr>
<tr class="memdesc:a3de538c8ac877750ba12b2c186fb375a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of tokens, each of which is delimited by a character from the string pointed to by delim.  <a href="#a3de538c8ac877750ba12b2c186fb375a">More...</a><br /></td></tr>
<tr class="separator:a3de538c8ac877750ba12b2c186fb375a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb56f5af9e3ad8eab7aad89b7756a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aafb56f5af9e3ad8eab7aad89b7756a9b">sprintf_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict fmt,...)</td></tr>
<tr class="memdesc:aafb56f5af9e3ad8eab7aad89b7756a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sprintf_s function composes a string with same test that would be printed if format was used on printf.  <a href="#aafb56f5af9e3ad8eab7aad89b7756a9b">More...</a><br /></td></tr>
<tr class="separator:aafb56f5af9e3ad8eab7aad89b7756a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9e1e5e6322ca4bf8cb5b1d6352a2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a6b9e1e5e6322ca4bf8cb5b1d6352a2e7">vsprintf_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:a6b9e1e5e6322ca4bf8cb5b1d6352a2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vsprintf_s</code> function composes a string with same test that would be printed if format was used on <code>printf</code>.  <a href="#a6b9e1e5e6322ca4bf8cb5b1d6352a2e7">More...</a><br /></td></tr>
<tr class="separator:a6b9e1e5e6322ca4bf8cb5b1d6352a2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48680eec2d6383a40b479234979a045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ae48680eec2d6383a40b479234979a045">snprintf_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict fmt,...)</td></tr>
<tr class="memdesc:ae48680eec2d6383a40b479234979a045"><td class="mdescLeft">&#160;</td><td class="mdescRight">The truncating <code>snprintf_s</code> function composes a string with same test that would be printed if format was used on <code>printf</code>.  <a href="#ae48680eec2d6383a40b479234979a045">More...</a><br /></td></tr>
<tr class="separator:ae48680eec2d6383a40b479234979a045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76247677ead8dabafadb6fc6d9ce4346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a76247677ead8dabafadb6fc6d9ce4346">vsnprintf_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:a76247677ead8dabafadb6fc6d9ce4346"><td class="mdescLeft">&#160;</td><td class="mdescRight">The truncating <code>vsnprintf_s</code> function composes a string with same test that would be printed if format was used on <code>printf</code>.  <a href="#a76247677ead8dabafadb6fc6d9ce4346">More...</a><br /></td></tr>
<tr class="separator:a76247677ead8dabafadb6fc6d9ce4346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b8a36709f6474c620d369e70b2309c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ad8b8a36709f6474c620d369e70b2309c">sscanf_s</a> (const char *restrict buffer, const char *restrict fmt,...)</td></tr>
<tr class="memdesc:ad8b8a36709f6474c620d369e70b2309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>sscanf_s</code> function reads a formatted string, and writes to a list of arguments.  <a href="#ad8b8a36709f6474c620d369e70b2309c">More...</a><br /></td></tr>
<tr class="separator:ad8b8a36709f6474c620d369e70b2309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4672e26e1f04843286f468a3c96afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a4d4672e26e1f04843286f468a3c96afe">fscanf_s</a> (FILE *restrict stream, const char *restrict format,...)</td></tr>
<tr class="memdesc:a4d4672e26e1f04843286f468a3c96afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>fscanf_s</code> function reads a formatted string from a buffered FILE stream, and writes to a list of arguments.  <a href="#a4d4672e26e1f04843286f468a3c96afe">More...</a><br /></td></tr>
<tr class="separator:a4d4672e26e1f04843286f468a3c96afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9efcc59a87e6ea1fa8aaccb2f4c9a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ae9efcc59a87e6ea1fa8aaccb2f4c9a00">scanf_s</a> (const char *restrict format,...)</td></tr>
<tr class="memdesc:ae9efcc59a87e6ea1fa8aaccb2f4c9a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>scanf_s</code> function reads a formatted string from stdin, and writes to a list of arguments.  <a href="#ae9efcc59a87e6ea1fa8aaccb2f4c9a00">More...</a><br /></td></tr>
<tr class="separator:ae9efcc59a87e6ea1fa8aaccb2f4c9a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792ab2d328b832d40618b9cae17b97d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a792ab2d328b832d40618b9cae17b97d5">vscanf_s</a> (const char *restrict format, va_list vlist)</td></tr>
<tr class="memdesc:a792ab2d328b832d40618b9cae17b97d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vscanf_s</code> function reads a formatted string from stdin, and writes to a list of arguments.  <a href="#a792ab2d328b832d40618b9cae17b97d5">More...</a><br /></td></tr>
<tr class="separator:a792ab2d328b832d40618b9cae17b97d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffe4d0267945bca8be68ca277c86776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a8ffe4d0267945bca8be68ca277c86776">vfscanf_s</a> (FILE *restrict stream, const char *restrict format, va_list vlist)</td></tr>
<tr class="memdesc:a8ffe4d0267945bca8be68ca277c86776"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vfscanf_s</code> function reads a formatted string from a buffered FILE stream, and writes to a list of arguments.  <a href="#a8ffe4d0267945bca8be68ca277c86776">More...</a><br /></td></tr>
<tr class="separator:a8ffe4d0267945bca8be68ca277c86776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8531e105a7c7eaf7a0758c0657d6eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ada8531e105a7c7eaf7a0758c0657d6eb">vsscanf_s</a> (const char *restrict buffer, const char *restrict format, va_list vlist)</td></tr>
<tr class="memdesc:ada8531e105a7c7eaf7a0758c0657d6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vsscanf_s</code> function reads a formatted string, and writes to a list of arguments.  <a href="#ada8531e105a7c7eaf7a0758c0657d6eb">More...</a><br /></td></tr>
<tr class="separator:ada8531e105a7c7eaf7a0758c0657d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460a1d3364e991ee9f36b6dca7ee77d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a460a1d3364e991ee9f36b6dca7ee77d6">printf_s</a> (const char *restrict format,...)</td></tr>
<tr class="memdesc:a460a1d3364e991ee9f36b6dca7ee77d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The printf_s function composes a string via the format string and writes it to a FILE buffer.  <a href="#a460a1d3364e991ee9f36b6dca7ee77d6">More...</a><br /></td></tr>
<tr class="separator:a460a1d3364e991ee9f36b6dca7ee77d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ed5ca61e0290bc13131951a27307e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a89ed5ca61e0290bc13131951a27307e9">fprintf_s</a> (FILE *restrict stream, const char *restrict format,...)</td></tr>
<tr class="memdesc:a89ed5ca61e0290bc13131951a27307e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fprintf_s function composes a string via the format string and writes it to a FILE buffer.  <a href="#a89ed5ca61e0290bc13131951a27307e9">More...</a><br /></td></tr>
<tr class="separator:a89ed5ca61e0290bc13131951a27307e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb9c5161658cd52484b66eb60a18538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a3cb9c5161658cd52484b66eb60a18538">vprintf_s</a> (const char *restrict format, va_list arg)</td></tr>
<tr class="memdesc:a3cb9c5161658cd52484b66eb60a18538"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vprintf_s function composes a string via the format string and writes it to a FILE buffer.  <a href="#a3cb9c5161658cd52484b66eb60a18538">More...</a><br /></td></tr>
<tr class="separator:a3cb9c5161658cd52484b66eb60a18538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b2bb4f72487b4eafac78d110334b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a59b2bb4f72487b4eafac78d110334b9f">vfprintf_s</a> (FILE *restrict stream, const char *restrict format, va_list arg)</td></tr>
<tr class="memdesc:a59b2bb4f72487b4eafac78d110334b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vfprintf_s function composes a string via the format string and writes it to a FILE buffer.  <a href="#a59b2bb4f72487b4eafac78d110334b9f">More...</a><br /></td></tr>
<tr class="separator:a59b2bb4f72487b4eafac78d110334b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f77e79ac9977b72ef64a94f3f70fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a14f77e79ac9977b72ef64a94f3f70fc2">strerror_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, errno_t errnum)</td></tr>
<tr class="memdesc:a14f77e79ac9977b72ef64a94f3f70fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>strerror_s</code> function returns a pointer to the textual description of the system error code errnum, identical to the description that would be printed by perror().  <a href="#a14f77e79ac9977b72ef64a94f3f70fc2">More...</a><br /></td></tr>
<tr class="separator:a14f77e79ac9977b72ef64a94f3f70fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf218acae58eaeb99428cbe2f9fe7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#afaf218acae58eaeb99428cbe2f9fe7d3">strerrorlen_s</a> (errno_t errnum)</td></tr>
<tr class="memdesc:afaf218acae58eaeb99428cbe2f9fe7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>strerrorlen_s</code> function returns the untruncated length of the textual description of the system error code <code>errnum</code>, identical to the description that would be printed by <code>perror()</code>.  <a href="#afaf218acae58eaeb99428cbe2f9fe7d3">More...</a><br /></td></tr>
<tr class="separator:afaf218acae58eaeb99428cbe2f9fe7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad0da7c4fe04e8800a1eef2d9bda3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a3ad0da7c4fe04e8800a1eef2d9bda3ec">strcmp_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, int *indicator)</td></tr>
<tr class="memdesc:a3ad0da7c4fe04e8800a1eef2d9bda3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares string src to string dest.  <a href="#a3ad0da7c4fe04e8800a1eef2d9bda3ec">More...</a><br /></td></tr>
<tr class="separator:a3ad0da7c4fe04e8800a1eef2d9bda3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe094189ed7156185c78d3180cd522d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a1fe094189ed7156185c78d3180cd522d">strcasecmp_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, int *indicator)</td></tr>
<tr class="memdesc:a1fe094189ed7156185c78d3180cd522d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case insensitive string comparison by converting to uppercase prior to the compare.  <a href="#a1fe094189ed7156185c78d3180cd522d">More...</a><br /></td></tr>
<tr class="separator:a1fe094189ed7156185c78d3180cd522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b38f74261dd0bb20957346dd8e25113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a2b38f74261dd0bb20957346dd8e25113">strcasestr_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen, char **substring)</td></tr>
<tr class="memdesc:a2b38f74261dd0bb20957346dd8e25113"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d6/d9e/strcasestr__s_8c.html#afaeb24871b940cfc3091c9fff24d4226" title="The strcasestr_s() function locates the first occurrence of the substring pointed to by src which wou...">strcasestr_s()</a> function locates the first occurrence of the substring pointed to by src which would be located in the string pointed to by dest.  <a href="#a2b38f74261dd0bb20957346dd8e25113">More...</a><br /></td></tr>
<tr class="separator:a2b38f74261dd0bb20957346dd8e25113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f913eed185743b3eaab5fbb8096eea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a6f913eed185743b3eaab5fbb8096eea7">strcmpfld_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, int *indicator)</td></tr>
<tr class="memdesc:a6f913eed185743b3eaab5fbb8096eea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the character array pointed to by src to the character array pointed to by dest for dmax characters.  <a href="#a6f913eed185743b3eaab5fbb8096eea7">More...</a><br /></td></tr>
<tr class="separator:a6f913eed185743b3eaab5fbb8096eea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaf439efea9f06742b98ad766a78727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#adcaf439efea9f06742b98ad766a78727">strcpyfld_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:adcaf439efea9f06742b98ad766a78727"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>strcpyfld_s</code> function copies <code>slen</code> characters from the character array pointed to by <code>src</code> into the character array pointed to by <code>dest</code>.  <a href="#adcaf439efea9f06742b98ad766a78727">More...</a><br /></td></tr>
<tr class="separator:adcaf439efea9f06742b98ad766a78727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63973653160bd3141f4648b58f3ae64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ad63973653160bd3141f4648b58f3ae64">strcpyfldin_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:ad63973653160bd3141f4648b58f3ae64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strcpyfldin_s function copies at most slen characters from the null terminated string pointed to by src into the fixed character array pointed to by dest.  <a href="#ad63973653160bd3141f4648b58f3ae64">More...</a><br /></td></tr>
<tr class="separator:ad63973653160bd3141f4648b58f3ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d8620276c0317f0cc87fb55741475b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a93d8620276c0317f0cc87fb55741475b">strcpyfldout_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a93d8620276c0317f0cc87fb55741475b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strcpyfldout_s function copies slen characters from the character array pointed to by src into the string pointed to by dest.  <a href="#a93d8620276c0317f0cc87fb55741475b">More...</a><br /></td></tr>
<tr class="separator:a93d8620276c0317f0cc87fb55741475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df8f61f2b3c5c2f7a7295ca79853828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a5df8f61f2b3c5c2f7a7295ca79853828">strcspn_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *count)</td></tr>
<tr class="memdesc:a5df8f61f2b3c5c2f7a7295ca79853828"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the prefix length of the string pointed to by dest which consists entirely of characters that are excluded from the string pointed to by src.  <a href="#a5df8f61f2b3c5c2f7a7295ca79853828">More...</a><br /></td></tr>
<tr class="separator:a5df8f61f2b3c5c2f7a7295ca79853828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a970d738ad33ab4d193a0f00a970a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a47a970d738ad33ab4d193a0f00a970a9">strfirstchar_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, char c, char **first)</td></tr>
<tr class="memdesc:a47a970d738ad33ab4d193a0f00a970a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a pointer to the first occurrence of character c in dest.  <a href="#a47a970d738ad33ab4d193a0f00a970a9">More...</a><br /></td></tr>
<tr class="separator:a47a970d738ad33ab4d193a0f00a970a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc5d71409ea37130532458a4abd360c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aafc5d71409ea37130532458a4abd360c">strfirstdiff_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *index)</td></tr>
<tr class="memdesc:aafc5d71409ea37130532458a4abd360c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first character that is different between dest and src.  <a href="#aafc5d71409ea37130532458a4abd360c">More...</a><br /></td></tr>
<tr class="separator:aafc5d71409ea37130532458a4abd360c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9548290da70633c318f4583cbaf96d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a9548290da70633c318f4583cbaf96d5e">strisalphanumeric_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a9548290da70633c318f4583cbaf96d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the entire string contains alphanumerics.  <a href="#a9548290da70633c318f4583cbaf96d5e">More...</a><br /></td></tr>
<tr class="separator:a9548290da70633c318f4583cbaf96d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526dd1c60bc2eef022c4743566203c38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a526dd1c60bc2eef022c4743566203c38">strisascii_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a526dd1c60bc2eef022c4743566203c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the entire string contains ascii characters.  <a href="#a526dd1c60bc2eef022c4743566203c38">More...</a><br /></td></tr>
<tr class="separator:a526dd1c60bc2eef022c4743566203c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d385633458d767bd9beacf413c4c7ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a5d385633458d767bd9beacf413c4c7ec">strisdigit_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a5d385633458d767bd9beacf413c4c7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks that the entire string contains digits.  <a href="#a5d385633458d767bd9beacf413c4c7ec">More...</a><br /></td></tr>
<tr class="separator:a5d385633458d767bd9beacf413c4c7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd555b3e2569803c5d75016f70124aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aebd555b3e2569803c5d75016f70124aa">strishex_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:aebd555b3e2569803c5d75016f70124aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks that the entire string contains hex characters.  <a href="#aebd555b3e2569803c5d75016f70124aa">More...</a><br /></td></tr>
<tr class="separator:aebd555b3e2569803c5d75016f70124aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c94eb45ded60347733f23a6d239e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a20c94eb45ded60347733f23a6d239e32">strislowercase_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a20c94eb45ded60347733f23a6d239e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if entire string is lowercase.  <a href="#a20c94eb45ded60347733f23a6d239e32">More...</a><br /></td></tr>
<tr class="separator:a20c94eb45ded60347733f23a6d239e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325b07c57952b98e580d777dc52175a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a325b07c57952b98e580d777dc52175a2">strismixedcase_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a325b07c57952b98e580d777dc52175a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks that the entire string is mixed case.  <a href="#a325b07c57952b98e580d777dc52175a2">More...</a><br /></td></tr>
<tr class="separator:a325b07c57952b98e580d777dc52175a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b06e5161c76aeb15b1f7692a2d5e44a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a6b06e5161c76aeb15b1f7692a2d5e44a">strispassword_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a6b06e5161c76aeb15b1f7692a2d5e44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function validates the make-up of a password string.  <a href="#a6b06e5161c76aeb15b1f7692a2d5e44a">More...</a><br /></td></tr>
<tr class="separator:a6b06e5161c76aeb15b1f7692a2d5e44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce12baf626ecaad13652bcac2c21f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#af7ce12baf626ecaad13652bcac2c21f7">strisuppercase_s</a> (const char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:af7ce12baf626ecaad13652bcac2c21f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if entire string is uppercase The scanning stops at the first null or after dmax characters.  <a href="#af7ce12baf626ecaad13652bcac2c21f7">More...</a><br /></td></tr>
<tr class="separator:af7ce12baf626ecaad13652bcac2c21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869f5038d30bff33f82415022d4da617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a869f5038d30bff33f82415022d4da617">strlastchar_s</a> (char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> smax, char c, char **first)</td></tr>
<tr class="memdesc:a869f5038d30bff33f82415022d4da617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the last occurrence of character c in dest.  <a href="#a869f5038d30bff33f82415022d4da617">More...</a><br /></td></tr>
<tr class="separator:a869f5038d30bff33f82415022d4da617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dfb6c764602668ed1eaae9d6df5410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa8dfb6c764602668ed1eaae9d6df5410">strlastdiff_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *index)</td></tr>
<tr class="memdesc:aa8dfb6c764602668ed1eaae9d6df5410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last character that is different between dest and src.  <a href="#aa8dfb6c764602668ed1eaae9d6df5410">More...</a><br /></td></tr>
<tr class="separator:aa8dfb6c764602668ed1eaae9d6df5410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e0c2157d99131ba398b76445e9de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a816e0c2157d99131ba398b76445e9de5">strljustify_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax)</td></tr>
<tr class="memdesc:a816e0c2157d99131ba398b76445e9de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes beginning whitespace from the string pointed to by dest by shifting the text left over writting the beginning whitespace, left justifying the text.  <a href="#a816e0c2157d99131ba398b76445e9de5">More...</a><br /></td></tr>
<tr class="separator:a816e0c2157d99131ba398b76445e9de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a2702b0c90ce02421115dfe9884f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a17a2702b0c90ce02421115dfe9884f8e">strnterminate_s</a> (char *s, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> smax)</td></tr>
<tr class="memdesc:a17a2702b0c90ce02421115dfe9884f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strnterminate_s function will terminate the string if a null is not encountered before dmax characters.  <a href="#a17a2702b0c90ce02421115dfe9884f8e">More...</a><br /></td></tr>
<tr class="separator:a17a2702b0c90ce02421115dfe9884f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e356eec3ebcf6ed95ad0758f125f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a60e356eec3ebcf6ed95ad0758f125f10">strpbrk_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen, char **first)</td></tr>
<tr class="memdesc:a60e356eec3ebcf6ed95ad0758f125f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer, first, to the first ocurrence of any character in src which is contained in dest.  <a href="#a60e356eec3ebcf6ed95ad0758f125f10">More...</a><br /></td></tr>
<tr class="separator:a60e356eec3ebcf6ed95ad0758f125f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbd16eab61a5c4eb818d48da3a3bcc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7bbd16eab61a5c4eb818d48da3a3bcc3">strfirstsame_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *index)</td></tr>
<tr class="memdesc:a7bbd16eab61a5c4eb818d48da3a3bcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first character that is the same between dest and src.  <a href="#a7bbd16eab61a5c4eb818d48da3a3bcc3">More...</a><br /></td></tr>
<tr class="separator:a7bbd16eab61a5c4eb818d48da3a3bcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce98e6dace379678bc5e1204cd79c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a6ce98e6dace379678bc5e1204cd79c32">strlastsame_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *index)</td></tr>
<tr class="memdesc:a6ce98e6dace379678bc5e1204cd79c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last character that is the same between dest and src.  <a href="#a6ce98e6dace379678bc5e1204cd79c32">More...</a><br /></td></tr>
<tr class="separator:a6ce98e6dace379678bc5e1204cd79c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3252f7ee23313f430a69bf2ff875a36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a3252f7ee23313f430a69bf2ff875a36b">strprefix_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src)</td></tr>
<tr class="memdesc:a3252f7ee23313f430a69bf2ff875a36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the prefix pointed to by src is at the beginning of string pointed to by dest.  <a href="#a3252f7ee23313f430a69bf2ff875a36b">More...</a><br /></td></tr>
<tr class="separator:a3252f7ee23313f430a69bf2ff875a36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddfa37f06f78adb9714262c3c9f6841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a4ddfa37f06f78adb9714262c3c9f6841">strremovews_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax)</td></tr>
<tr class="memdesc:a4ddfa37f06f78adb9714262c3c9f6841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes beginning and trailing whitespace from the string pointed to by dest by shifting the text left over writting the beginning whitespace (space or tab).  <a href="#a4ddfa37f06f78adb9714262c3c9f6841">More...</a><br /></td></tr>
<tr class="separator:a4ddfa37f06f78adb9714262c3c9f6841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f1003adfb3b52164ce332b72d51678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ac4f1003adfb3b52164ce332b72d51678">strspn_s</a> (const char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *count)</td></tr>
<tr class="memdesc:ac4f1003adfb3b52164ce332b72d51678"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the prefix length of the string pointed to by dest which consists entirely of characters that are included from the string pointed to by src.  <a href="#ac4f1003adfb3b52164ce332b72d51678">More...</a><br /></td></tr>
<tr class="separator:ac4f1003adfb3b52164ce332b72d51678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abe995a4bd9200e4b2ae14e98bea44c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a2abe995a4bd9200e4b2ae14e98bea44c">strstr_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen, char **substring)</td></tr>
<tr class="memdesc:a2abe995a4bd9200e4b2ae14e98bea44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a> function locates the first occurrence of the substring pointed to by src which would be located in the string pointed to by dest.  <a href="#a2abe995a4bd9200e4b2ae14e98bea44c">More...</a><br /></td></tr>
<tr class="separator:a2abe995a4bd9200e4b2ae14e98bea44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae4847201ef47b5f0b869881d26ed2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a6ae4847201ef47b5f0b869881d26ed2b">strchr_s</a> (const char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const int ch, char **result)</td></tr>
<tr class="memdesc:a6ae4847201ef47b5f0b869881d26ed2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated byte string pointed to by dest (each character interpreted as unsigned char).  <a href="#a6ae4847201ef47b5f0b869881d26ed2b">More...</a><br /></td></tr>
<tr class="separator:a6ae4847201ef47b5f0b869881d26ed2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5b47f61548fcec9fc7bc95877c8554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a3a5b47f61548fcec9fc7bc95877c8554">strrchr_s</a> (const char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const int ch, char **result)</td></tr>
<tr class="memdesc:a3a5b47f61548fcec9fc7bc95877c8554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated byte string pointed to by dest (each character interpreted as unsigned char).  <a href="#a3a5b47f61548fcec9fc7bc95877c8554">More...</a><br /></td></tr>
<tr class="separator:a3a5b47f61548fcec9fc7bc95877c8554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d393f60f6de53c22c2285ec379a046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a39d393f60f6de53c22c2285ec379a046">strtolowercase_s</a> (char *restrict str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a39d393f60f6de53c22c2285ec379a046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the string converting uppercase characters to lowercase, leaving all other characters unchanged.  <a href="#a39d393f60f6de53c22c2285ec379a046">More...</a><br /></td></tr>
<tr class="separator:a39d393f60f6de53c22c2285ec379a046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d442591898fb246a2bd5aa590a6921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a38d442591898fb246a2bd5aa590a6921">strtouppercase_s</a> (char *str, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a38d442591898fb246a2bd5aa590a6921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged.  <a href="#a38d442591898fb246a2bd5aa590a6921">More...</a><br /></td></tr>
<tr class="separator:a38d442591898fb246a2bd5aa590a6921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cdabeafa0bdc6d3af9a37d70e24103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa4cdabeafa0bdc6d3af9a37d70e24103">strzero_s</a> (char *dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax)</td></tr>
<tr class="memdesc:aa4cdabeafa0bdc6d3af9a37d70e24103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nulls maximal dmax characters of dest.  <a href="#aa4cdabeafa0bdc6d3af9a37d70e24103">More...</a><br /></td></tr>
<tr class="separator:aa4cdabeafa0bdc6d3af9a37d70e24103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b22cfd1f08f4bbdbc805ae997f8cb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a4b22cfd1f08f4bbdbc805ae997f8cb49">strcoll_s</a> (const char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict src, int *indicator)</td></tr>
<tr class="memdesc:a4b22cfd1f08f4bbdbc805ae997f8cb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two null-terminated byte strings according to the current locale as defined by the <code>LC_COLLATE</code> category.  <a href="#a4b22cfd1f08f4bbdbc805ae997f8cb49">More...</a><br /></td></tr>
<tr class="separator:a4b22cfd1f08f4bbdbc805ae997f8cb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa017ab253b65c6fda098dc6ae06afe20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa017ab253b65c6fda098dc6ae06afe20">strset_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, int value)</td></tr>
<tr class="memdesc:aa017ab253b65c6fda098dc6ae06afe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets maximal dmax characters of dest to a character value, but not the final NULL character.  <a href="#aa017ab253b65c6fda098dc6ae06afe20">More...</a><br /></td></tr>
<tr class="separator:aa017ab253b65c6fda098dc6ae06afe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde4cdc3194a0f9facdf2956ca88cdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#adde4cdc3194a0f9facdf2956ca88cdca">strnset_s</a> (char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, int value, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> n)</td></tr>
<tr class="memdesc:adde4cdc3194a0f9facdf2956ca88cdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets maximal n characters of dest to a character value, but not the final NULL character.  <a href="#adde4cdc3194a0f9facdf2956ca88cdca">More...</a><br /></td></tr>
<tr class="separator:adde4cdc3194a0f9facdf2956ca88cdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba404d1c29fcf07405871166222e61f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aba404d1c29fcf07405871166222e61f4">mbstowcs_s</a> (size_t *restrict retval, wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> <a class="el" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>)</td></tr>
<tr class="separator:aba404d1c29fcf07405871166222e61f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb3b0ad918710ecfe6fe25e58cb7410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#addb3b0ad918710ecfe6fe25e58cb7410">mbsrtowcs_s</a> (size_t *restrict retval, wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const char **restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> <a class="el" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, mbstate_t *restrict ps)</td></tr>
<tr class="memdesc:addb3b0ad918710ecfe6fe25e58cb7410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does not permit the <code>ps</code> parameter (the pointer to the conversion state) to be a null pointer.  <a href="#addb3b0ad918710ecfe6fe25e58cb7410">More...</a><br /></td></tr>
<tr class="separator:addb3b0ad918710ecfe6fe25e58cb7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0999a2ddd3afe9c4538d029dce4fb90b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a0999a2ddd3afe9c4538d029dce4fb90b">wcsrtombs_s</a> (size_t *restrict retval, char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t **restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> <a class="el" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, mbstate_t *restrict ps)</td></tr>
<tr class="memdesc:a0999a2ddd3afe9c4538d029dce4fb90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does not permit the <code>ps</code> parameter (the pointer to the conversion state) to be a null pointer.  <a href="#a0999a2ddd3afe9c4538d029dce4fb90b">More...</a><br /></td></tr>
<tr class="separator:a0999a2ddd3afe9c4538d029dce4fb90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad803161f1adba44ff57a7c751549221c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ad803161f1adba44ff57a7c751549221c">wcstombs_s</a> (size_t *restrict retval, char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> <a class="el" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>)</td></tr>
<tr class="memdesc:ad803161f1adba44ff57a7c751549221c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>wcstombs_s</code> function converts a sequence of wide characters from the array whose first element is pointed to by <code>src</code> to to its narrow multibyte representation from the current LC_CTYPE locale.  <a href="#ad803161f1adba44ff57a7c751549221c">More...</a><br /></td></tr>
<tr class="separator:ad803161f1adba44ff57a7c751549221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7294e6f32936b6d2905282e710d97da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7294e6f32936b6d2905282e710d97da6">wcrtomb_s</a> (size_t *restrict retval, char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t wc, mbstate_t *restrict ps)</td></tr>
<tr class="memdesc:a7294e6f32936b6d2905282e710d97da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does not permit the <code>ps</code> parameter (the pointer to the conversion state) to be a null pointer.  <a href="#a7294e6f32936b6d2905282e710d97da6">More...</a><br /></td></tr>
<tr class="separator:a7294e6f32936b6d2905282e710d97da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e1df63ddc71b3307d2964bc88af81c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a88e1df63ddc71b3307d2964bc88af81c">wctomb_s</a> (int *restrict retval, char *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t wc)</td></tr>
<tr class="memdesc:a88e1df63ddc71b3307d2964bc88af81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>wctomb_s</code> function converts a single wide character to its narrow multibyte representation from the current LC_CTYPE locale.  <a href="#a88e1df63ddc71b3307d2964bc88af81c">More...</a><br /></td></tr>
<tr class="separator:a88e1df63ddc71b3307d2964bc88af81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07831ddbabb97091c8470ee047dc9b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a07831ddbabb97091c8470ee047dc9b0c">wcsnlen_s</a> (const wchar_t *dest, size_t dmax)</td></tr>
<tr class="memdesc:a07831ddbabb97091c8470ee047dc9b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wcsnlen_s function computes the length of the wide string pointed to by dest.  <a href="#a07831ddbabb97091c8470ee047dc9b0c">More...</a><br /></td></tr>
<tr class="separator:a07831ddbabb97091c8470ee047dc9b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed99e0d3d9effb78c6f47965460723f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aed99e0d3d9effb78c6f47965460723f2">wcscpy_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src)</td></tr>
<tr class="memdesc:aed99e0d3d9effb78c6f47965460723f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>wcscpy_s</code> function copies the string pointed to by <code>src</code> (including the terminating null character) into the array pointed to by dest.  <a href="#aed99e0d3d9effb78c6f47965460723f2">More...</a><br /></td></tr>
<tr class="separator:aed99e0d3d9effb78c6f47965460723f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13519fd510a16c6022720d90f0b360cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a13519fd510a16c6022720d90f0b360cf">wcsncpy_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a13519fd510a16c6022720d90f0b360cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wcsncpy_s function copies the wide string pointed to by src (including the terminating null character) into the wide string pointed to by dest.  <a href="#a13519fd510a16c6022720d90f0b360cf">More...</a><br /></td></tr>
<tr class="separator:a13519fd510a16c6022720d90f0b360cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725971d12803e7cb5c62c476b387ac74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a725971d12803e7cb5c62c476b387ac74">wcscat_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src)</td></tr>
<tr class="memdesc:a725971d12803e7cb5c62c476b387ac74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wcscat_s function appends a copy of the wide string pointed to by src (including the terminating null character) to the end of the wide string pointed to by dest.  <a href="#a725971d12803e7cb5c62c476b387ac74">More...</a><br /></td></tr>
<tr class="separator:a725971d12803e7cb5c62c476b387ac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28268c019a36d36840b6ea11140e7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ad28268c019a36d36840b6ea11140e7e0">wcsncat_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:ad28268c019a36d36840b6ea11140e7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wcsncat_s function appends a copy of the wide string pointed to by src (including the terminating null wide character) to the end of the wide string pointed to by dest.  <a href="#ad28268c019a36d36840b6ea11140e7e0">More...</a><br /></td></tr>
<tr class="separator:ad28268c019a36d36840b6ea11140e7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a2dbd151501d66b1f22706c63a25db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#af1a2dbd151501d66b1f22706c63a25db">wcstok_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict dmax, const wchar_t *restrict delim, wchar_t **restrict ptr)</td></tr>
<tr class="memdesc:af1a2dbd151501d66b1f22706c63a25db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of tokens, each of which is delimited by a character from the string pointed to by delim.  <a href="#af1a2dbd151501d66b1f22706c63a25db">More...</a><br /></td></tr>
<tr class="separator:af1a2dbd151501d66b1f22706c63a25db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea1769556656f26090c5fe2b94aa2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a78ea1769556656f26090c5fe2b94aa2d">swprintf_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict fmt,...)</td></tr>
<tr class="memdesc:a78ea1769556656f26090c5fe2b94aa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>swprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>.  <a href="#a78ea1769556656f26090c5fe2b94aa2d">More...</a><br /></td></tr>
<tr class="separator:a78ea1769556656f26090c5fe2b94aa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e11f5eec2d7783dd8dea450121f74b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a91e11f5eec2d7783dd8dea450121f74b">vswprintf_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:a91e11f5eec2d7783dd8dea450121f74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vswprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>.  <a href="#a91e11f5eec2d7783dd8dea450121f74b">More...</a><br /></td></tr>
<tr class="separator:a91e11f5eec2d7783dd8dea450121f74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa23a1b9bb76cbeba8848f07a0ab50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7fa23a1b9bb76cbeba8848f07a0ab50c">snwprintf_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict fmt,...)</td></tr>
<tr class="memdesc:a7fa23a1b9bb76cbeba8848f07a0ab50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The truncating <code>snwprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>.  <a href="#a7fa23a1b9bb76cbeba8848f07a0ab50c">More...</a><br /></td></tr>
<tr class="separator:a7fa23a1b9bb76cbeba8848f07a0ab50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0457ee1141935980d88b74321a128ab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a0457ee1141935980d88b74321a128ab4">vsnwprintf_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:a0457ee1141935980d88b74321a128ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The truncating <code>vsnwprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>.  <a href="#a0457ee1141935980d88b74321a128ab4">More...</a><br /></td></tr>
<tr class="separator:a0457ee1141935980d88b74321a128ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390b28c7682a043fd97c142e4d3906f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a390b28c7682a043fd97c142e4d3906f4">wprintf_s</a> (const wchar_t *restrict fmt,...)</td></tr>
<tr class="memdesc:a390b28c7682a043fd97c142e4d3906f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wprintf_s function prints formatted output to stdout as wide string.  <a href="#a390b28c7682a043fd97c142e4d3906f4">More...</a><br /></td></tr>
<tr class="separator:a390b28c7682a043fd97c142e4d3906f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360e076fff606b3767da440b220eb39b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a360e076fff606b3767da440b220eb39b">vwprintf_s</a> (const wchar_t *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:a360e076fff606b3767da440b220eb39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vwprintf_s function prints formatted output to stdout as wide string.  <a href="#a360e076fff606b3767da440b220eb39b">More...</a><br /></td></tr>
<tr class="separator:a360e076fff606b3767da440b220eb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd405ffe5ad436fbe18ff80da8dcf16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a4bd405ffe5ad436fbe18ff80da8dcf16">fwprintf_s</a> (FILE *restrict stream, const wchar_t *restrict fmt,...)</td></tr>
<tr class="memdesc:a4bd405ffe5ad436fbe18ff80da8dcf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fwprintf_s function prints formatted output to a wide stream.  <a href="#a4bd405ffe5ad436fbe18ff80da8dcf16">More...</a><br /></td></tr>
<tr class="separator:a4bd405ffe5ad436fbe18ff80da8dcf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3f8921f47a6e50005ad675109f207f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a2c3f8921f47a6e50005ad675109f207f">vfwprintf_s</a> (FILE *restrict stream, const wchar_t *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:a2c3f8921f47a6e50005ad675109f207f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vfwprintf_s function prints formatted output to a wide stream.  <a href="#a2c3f8921f47a6e50005ad675109f207f">More...</a><br /></td></tr>
<tr class="separator:a2c3f8921f47a6e50005ad675109f207f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a093e276412353fcb09dab51b2c732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a96a093e276412353fcb09dab51b2c732">swscanf_s</a> (const wchar_t *restrict buffer, const wchar_t *restrict fmt,...)</td></tr>
<tr class="memdesc:a96a093e276412353fcb09dab51b2c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>swscanf_s</code> function reads a formatted wide string.  <a href="#a96a093e276412353fcb09dab51b2c732">More...</a><br /></td></tr>
<tr class="separator:a96a093e276412353fcb09dab51b2c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5b8d45187ca36d5a986bd54abefb53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aae5b8d45187ca36d5a986bd54abefb53">vswscanf_s</a> (const wchar_t *restrict buffer, const wchar_t *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:aae5b8d45187ca36d5a986bd54abefb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vswscanf_s</code> function reads a formatted wide string.  <a href="#aae5b8d45187ca36d5a986bd54abefb53">More...</a><br /></td></tr>
<tr class="separator:aae5b8d45187ca36d5a986bd54abefb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc67e003c3fc2a77921af9a657304d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a9dc67e003c3fc2a77921af9a657304d1">wscanf_s</a> (const wchar_t *restrict fmt,...)</td></tr>
<tr class="memdesc:a9dc67e003c3fc2a77921af9a657304d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>wscanf_s</code> function reads a formatted wide string from stdin.  <a href="#a9dc67e003c3fc2a77921af9a657304d1">More...</a><br /></td></tr>
<tr class="separator:a9dc67e003c3fc2a77921af9a657304d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f67a9930496e53ce6af7451956893d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ad0f67a9930496e53ce6af7451956893d">vwscanf_s</a> (const wchar_t *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:ad0f67a9930496e53ce6af7451956893d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vwscanf_s</code> function reads a formatted wide string from stdin.  <a href="#ad0f67a9930496e53ce6af7451956893d">More...</a><br /></td></tr>
<tr class="separator:ad0f67a9930496e53ce6af7451956893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b0c51d92250649124c09c6cabda5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ab1b0c51d92250649124c09c6cabda5b0">fwscanf_s</a> (FILE *restrict stream, const wchar_t *restrict fmt,...)</td></tr>
<tr class="memdesc:ab1b0c51d92250649124c09c6cabda5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>fwscanf_s</code> function reads a formatted wide string.  <a href="#ab1b0c51d92250649124c09c6cabda5b0">More...</a><br /></td></tr>
<tr class="separator:ab1b0c51d92250649124c09c6cabda5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283406eecc0fb4828affaf7e1017ac50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a283406eecc0fb4828affaf7e1017ac50">vfwscanf_s</a> (FILE *restrict stream, const wchar_t *restrict fmt, va_list ap)</td></tr>
<tr class="memdesc:a283406eecc0fb4828affaf7e1017ac50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>vfwscanf_s</code> function reads a formatted wide string.  <a href="#a283406eecc0fb4828affaf7e1017ac50">More...</a><br /></td></tr>
<tr class="separator:a283406eecc0fb4828affaf7e1017ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf72c3bb30ce5adb59114e98924a7f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#abf72c3bb30ce5adb59114e98924a7f18">wcsstr_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen, wchar_t **restrict substring)</td></tr>
<tr class="memdesc:abf72c3bb30ce5adb59114e98924a7f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dd/df8/wcsstr__s_8c.html#ac5149ef531b176db7a27bde6ff1bbf2e" title="The wcsstr_s() function locates the first occurrence of the wide substring pointed to by src which wo...">wcsstr_s()</a> function locates the first occurrence of the wide substring pointed to by src which would be located in the wide string pointed to by dest.  <a href="#abf72c3bb30ce5adb59114e98924a7f18">More...</a><br /></td></tr>
<tr class="separator:abf72c3bb30ce5adb59114e98924a7f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa822b7efba53861a233dcee6651178a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa822b7efba53861a233dcee6651178a8">wcscmp_s</a> (const wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> smax, int *diff)</td></tr>
<tr class="memdesc:aa822b7efba53861a233dcee6651178a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares wide string src to wide string dest.  <a href="#aa822b7efba53861a233dcee6651178a8">More...</a><br /></td></tr>
<tr class="separator:aa822b7efba53861a233dcee6651178a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039ed28ddc950839174ae1994ec32b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a039ed28ddc950839174ae1994ec32b56">wcsncmp_s</a> (const wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> smax, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> count, int *diff)</td></tr>
<tr class="memdesc:a039ed28ddc950839174ae1994ec32b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count wide characters of wide string src with wide string dest.  <a href="#a039ed28ddc950839174ae1994ec32b56">More...</a><br /></td></tr>
<tr class="separator:a039ed28ddc950839174ae1994ec32b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079058b84cb9b4ecd989d5a8be844fa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a079058b84cb9b4ecd989d5a8be844fa4">wcsicmp_s</a> (const wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> smax, int *diff)</td></tr>
<tr class="memdesc:a079058b84cb9b4ecd989d5a8be844fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two wide strings case-folded, via <code><a class="el" href="../../d9/d47/wcsfc__s_8c.html#a692cc4f6619a725907aa0b227f443950" title="Converts the wide string via full case-folding NFD normalized to lowercase. ">wcsfc_s()</a></code>, i.e.  <a href="#a079058b84cb9b4ecd989d5a8be844fa4">More...</a><br /></td></tr>
<tr class="separator:a079058b84cb9b4ecd989d5a8be844fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5d4da1de92882c5e14473007cd1d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a3a5d4da1de92882c5e14473007cd1d2e">wcsset_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t value)</td></tr>
<tr class="memdesc:a3a5d4da1de92882c5e14473007cd1d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets maximal dmax wide characters of dest to a wide character value, but not the final NULL character.  <a href="#a3a5d4da1de92882c5e14473007cd1d2e">More...</a><br /></td></tr>
<tr class="separator:a3a5d4da1de92882c5e14473007cd1d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736f4779804a3b2b64cc343daab842f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a736f4779804a3b2b64cc343daab842f5">wcsnset_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t value, size_t n)</td></tr>
<tr class="memdesc:a736f4779804a3b2b64cc343daab842f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets maximal n wide characters of dest to a wide character value, but not the final NULL character.  <a href="#a736f4779804a3b2b64cc343daab842f5">More...</a><br /></td></tr>
<tr class="separator:a736f4779804a3b2b64cc343daab842f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02e31cc793591dcc0347f218cacced2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ab02e31cc793591dcc0347f218cacced2">wcscoll_s</a> (const wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> smax, int *indicator)</td></tr>
<tr class="memdesc:ab02e31cc793591dcc0347f218cacced2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two null-terminated wide strings according to the current locale as defined by the <code>LC_COLLATE</code> category.  <a href="#ab02e31cc793591dcc0347f218cacced2">More...</a><br /></td></tr>
<tr class="separator:ab02e31cc793591dcc0347f218cacced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a758ea56cc6e264c7be20fad0b0e96d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7a758ea56cc6e264c7be20fad0b0e96d">wcslwr_s</a> (wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:a7a758ea56cc6e264c7be20fad0b0e96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the string converting uppercase characters to simple lowercase, leaving all other characters unchanged.  <a href="#a7a758ea56cc6e264c7be20fad0b0e96d">More...</a><br /></td></tr>
<tr class="separator:a7a758ea56cc6e264c7be20fad0b0e96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c4be91bfb2f09257359dac2c3d79e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ab9c4be91bfb2f09257359dac2c3d79e4">wcsupr_s</a> (wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> slen)</td></tr>
<tr class="memdesc:ab9c4be91bfb2f09257359dac2c3d79e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged.  <a href="#ab9c4be91bfb2f09257359dac2c3d79e4">More...</a><br /></td></tr>
<tr class="separator:ab9c4be91bfb2f09257359dac2c3d79e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce699d737a73dcdbcdd2355460bfd18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#abce699d737a73dcdbcdd2355460bfd18">iswfc</a> (wint_t wc)</td></tr>
<tr class="separator:abce699d737a73dcdbcdd2355460bfd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe56564b1f33f33e0d98ff9597d66c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#abe56564b1f33f33e0d98ff9597d66c58">towfc_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, const wint_t src)</td></tr>
<tr class="memdesc:abe56564b1f33f33e0d98ff9597d66c58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="../../dc/d32/towfc__s_8c.html#a641c8489795192bd197158bb662de3c3" title="towfc_s() converts a wide character to fully fold-cased (lowercased with possible expansions)...">towfc_s()</a></code> converts a wide character to fully fold-cased (lowercased with possible expansions), according to the Unicode 10.0 CaseFolding table.  <a href="#abe56564b1f33f33e0d98ff9597d66c58">More...</a><br /></td></tr>
<tr class="separator:abe56564b1f33f33e0d98ff9597d66c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace20c4b157616ba08041aaf95fafd0b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ace20c4b157616ba08041aaf95fafd0b5">wcsfc_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict lenp)</td></tr>
<tr class="memdesc:ace20c4b157616ba08041aaf95fafd0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the wide string via full case-folding NFD normalized to lowercase.  <a href="#ace20c4b157616ba08041aaf95fafd0b5">More...</a><br /></td></tr>
<tr class="separator:ace20c4b157616ba08041aaf95fafd0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231a238a9b9c9efef492ea937f9ab98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a231a238a9b9c9efef492ea937f9ab98e">wcsnorm_decompose_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict lenp, bool iscompat)</td></tr>
<tr class="memdesc:a231a238a9b9c9efef492ea937f9ab98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the wide string to the canonical NFD normalization, as defined in the latest Unicode standard, latest 10.0.  <a href="#a231a238a9b9c9efef492ea937f9ab98e">More...</a><br /></td></tr>
<tr class="separator:a231a238a9b9c9efef492ea937f9ab98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f58652f1c559c0ff9da8511983c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#aa90f58652f1c559c0ff9da8511983c10">wcsnorm_reorder_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> <a class="el" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>)</td></tr>
<tr class="memdesc:aa90f58652f1c559c0ff9da8511983c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder all decomposed sequences in a wide string to NFD, as defined in the latest Unicode standard, latest 10.0.  <a href="#aa90f58652f1c559c0ff9da8511983c10">More...</a><br /></td></tr>
<tr class="separator:aa90f58652f1c559c0ff9da8511983c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e80633c6c5a2ac8a07b567e0e9cb7f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a8e80633c6c5a2ac8a07b567e0e9cb7f2">wcsnorm_compose_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t *restrict src, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict lenp, bool iscontig)</td></tr>
<tr class="memdesc:a8e80633c6c5a2ac8a07b567e0e9cb7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine all decomposed sequences in a wide string to NFC, as defined in the latest Unicode standard, latest 10.0.  <a href="#a8e80633c6c5a2ac8a07b567e0e9cb7f2">More...</a><br /></td></tr>
<tr class="separator:a8e80633c6c5a2ac8a07b567e0e9cb7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3de15134919337fbf0084b95961bd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#ae3de15134919337fbf0084b95961bd7c">wcsnorm_s</a> (wchar_t *restrict dest, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> dmax, wchar_t *restrict src, <a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7e951343fed5789c4ec0a61bace0b135">wcsnorm_mode_t</a> mode, <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict lenp)</td></tr>
<tr class="memdesc:ae3de15134919337fbf0084b95961bd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the wide string to the canonical NFC or NFD normalization, as defined in the latest Unicode standard, latest 10.0.  <a href="#ae3de15134919337fbf0084b95961bd7c">More...</a><br /></td></tr>
<tr class="separator:ae3de15134919337fbf0084b95961bd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a77366c1bd428629dc898e188bfd182a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77366c1bd428629dc898e188bfd182a3">&#9670;&nbsp;</a></span>EXTERN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXTERN&#160;&#160;&#160;extern</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a848ae7e999628921f4b96fc11e1c4005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848ae7e999628921f4b96fc11e1c4005">&#9670;&nbsp;</a></span>RSIZE_MIN_STR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RSIZE_MIN_STR&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af37c2dfd05a44edf71ed743e1fb65d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37c2dfd05a44edf71ed743e1fb65d36">&#9670;&nbsp;</a></span>RSIZE_MAX_WSTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RSIZE_MAX_WSTR&#160;&#160;&#160;( <a class="el" href="../../d3/ddb/safe__config_8h.html#a05ab44a94e05e033959f296e9b2796fc">RSIZE_MAX_STR</a>/sizeof(wchar_t) )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5df79107e349c3cbe5843e22549ffe9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df79107e349c3cbe5843e22549ffe9d">&#9670;&nbsp;</a></span>SAFE_STR_MIN_LOWERCASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_STR_MIN_LOWERCASE&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd55d8f01e69e8764baa2cacddd1e0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd55d8f01e69e8764baa2cacddd1e0c0">&#9670;&nbsp;</a></span>SAFE_STR_MIN_UPPERCASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_STR_MIN_UPPERCASE&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b1b167253e62ad73e919e706f2881a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1b167253e62ad73e919e706f2881a1">&#9670;&nbsp;</a></span>SAFE_STR_MIN_NUMBERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_STR_MIN_NUMBERS&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2a88d55101f78c306eff57eeb5e96f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a88d55101f78c306eff57eeb5e96f5">&#9670;&nbsp;</a></span>SAFE_STR_MIN_SPECIALS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_STR_MIN_SPECIALS&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ad5ec9e1933bab308f8157d8f9b1296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad5ec9e1933bab308f8157d8f9b1296">&#9670;&nbsp;</a></span>SAFE_STR_PASSWORD_MIN_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_STR_PASSWORD_MIN_LENGTH&#160;&#160;&#160;( 6 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27dbd49bd0bab60ec22e31f47759bd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dbd49bd0bab60ec22e31f47759bd2a">&#9670;&nbsp;</a></span>SAFE_STR_PASSWORD_MAX_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_STR_PASSWORD_MAX_LENGTH&#160;&#160;&#160;( 32 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3838c5a9d1c42f1794cc142eaaceab1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3838c5a9d1c42f1794cc142eaaceab1c">&#9670;&nbsp;</a></span>sl_default_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sl_default_handler&#160;&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7fdc3594c01813cc1fdf77dc378715de">ignore_handler_s</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a680ec7c15269eddc82121895650a737a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680ec7c15269eddc82121895650a737a">&#9670;&nbsp;</a></span>strlwr_s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define strlwr_s</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a39d393f60f6de53c22c2285ec379a046">strtolowercase_s</a>((str), (slen))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeee34569f251b5bb3631aa4e4be522c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee34569f251b5bb3631aa4e4be522c7">&#9670;&nbsp;</a></span>strupr_s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define strupr_s</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d8/dff/safe__str__lib_8h.html#a38d442591898fb246a2bd5aa590a6921">strtouppercase_s</a>((str), (slen))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7e951343fed5789c4ec0a61bace0b135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e951343fed5789c4ec0a61bace0b135">&#9670;&nbsp;</a></span>wcsnorm_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50">wcsnorm_mode</a> <a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7e951343fed5789c4ec0a61bace0b135">wcsnorm_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a697d7515ad4cf3ad48348c7df8ec3a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697d7515ad4cf3ad48348c7df8ec3a50">&#9670;&nbsp;</a></span>wcsnorm_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50">wcsnorm_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a697d7515ad4cf3ad48348c7df8ec3a50ae39f2c22080365c283487fea1ad7b28c"></a>WCSNORM_NFD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a697d7515ad4cf3ad48348c7df8ec3a50a501e8094ee08cc856acc05eefa75d9df"></a>WCSNORM_NFC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a697d7515ad4cf3ad48348c7df8ec3a50af8079f81dd7039ba42c612e75e0a1676"></a>WCSNORM_FCD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a697d7515ad4cf3ad48348c7df8ec3a50a2a991639d09c68b33630fce968285acc"></a>WCSNORM_FCC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a697d7515ad4cf3ad48348c7df8ec3a50aec3bda705e086f32ef4b631f59fb5ad7"></a>WCSNORM_NFKD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a697d7515ad4cf3ad48348c7df8ec3a50a1ca77d91d24686356b7c7f243d78137e"></a>WCSNORM_NFKC&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a58587c173fa4c66368d5ba43095d6f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58587c173fa4c66368d5ba43095d6f72">&#9670;&nbsp;</a></span>abort_handler_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> void abort_handler_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">errno_t&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a message on the standard error stream in an implementation-defined format. </p>
<p>The message shall include the string pointed to by msg. The abort_handler_s function then calls the abort function.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message describing the error </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to aassociated data. Can be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The error code encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/dac/ignore__handler__s_8c.html#a33a2e940941f23b0f5d48880ff948b5a" title="This function simply returns to the caller. ">ignore_handler_s()</a> </dd></dl>

</div>
</div>
<a id="a7fdc3594c01813cc1fdf77dc378715de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdc3594c01813cc1fdf77dc378715de">&#9670;&nbsp;</a></span>ignore_handler_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> void ignore_handler_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">errno_t&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function simply returns to the caller. </p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message describing the error </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to aassociated data. Can be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The error code encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d04/abort__handler__s_8c.html#a32615c555cc58730a5123607d2c21e56" title="This function writes a message on the standard error stream in an implementation-defined format...">abort_handler_s()</a> </dd></dl>

</div>
</div>
<a id="aff0dee168db30fa183ed12b8de14fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0dee168db30fa183ed12b8de14fd0b">&#9670;&nbsp;</a></span>set_str_constraint_handler_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> <a class="el" href="../../dd/d0a/safe__types_8h.html#a94a54e98967ccb6be4bb4ad7e39fc290">constraint_handler_t</a> set_str_constraint_handler_s </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a94a54e98967ccb6be4bb4ad7e39fc290">constraint_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set_str_constraint_handler_s function sets the runtime-constraint handler to be handler. </p>
<p>The runtime-constraint handler is the function to be called when a library function detects a runtime-constraint violation. Only the most recent handler registered with set_str_constraint_handler_s is called when a runtime-constraint violation occurs. When the handler is called, it is passed the following arguments in the following order:</p><ol type="1">
<li>A pointer to a character string describing the runtime-constraint violation.</li>
<li>A null pointer or a pointer to an implementation defined object.</li>
<li>If the function calling the handler has a return type declared as errno_t, the return value of the function is passed. Otherwise, a positive value of type errno_t is passed. The implementation has a default constraint handler that is used if no calls to the set_constraint_handler_s function have been made. The behavior of the default handler is implementation-defined, and it may cause the program to exit or abort. If the handler argument to set_constraint_handler_s is a null pointer, the implementation default handler becomes the current constraint handler.</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d53/safe__str__constraint_8c.html#a596833872de6fd62a0e7f013bab34cb2" title="The set_str_constraint_handler_s function sets the runtime-constraint handler to be handler...">set_str_constraint_handler_s()</a> </dd></dl>

</div>
</div>
<a id="aa24c1a4615dbfb0970303132bb2785e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24c1a4615dbfb0970303132bb2785e3">&#9670;&nbsp;</a></span>strcat_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcat_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strcat_s function appends a copy of the string pointed to by src (including the terminating null character) to the end of the string pointed to by dest. </p>
<p>The initial character from src overwrites the null character at the end ofdest.</p>
<p>All elements following the terminating null character (if any) written by strcat_s in the array of dmax characters pointed to by dest take unspecied values when strcat_s returns. With SAFECLIB_STR_NULL_SLACK defined the rest is cleared with NULL bytes.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.2.1 The strcat_s function (p: 617-618) <a href="http://en.cppreference.com/w/c/string/byte/strcat">http://en.cppreference.com/w/c/string/byte/strcat</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be extended by src if dmax allows. The string is null terminated. If the resulting concatenated string is less than dmax, the remaining slack space is nulled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of the resulting dest, including the null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string that will be concatenaed to string dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer </dd>
<dd>
dmax shall not equal zero </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR </dd>
<dd>
dmax shall be greater than strnlen_s(src,m). </dd>
<dd>
Copying shall not take place between objects that overlap</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_STR, then strcat_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, all the characters from src were appended to dest and the result in dest is null terminated. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest or src is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESUNTERM</td><td>when dest not terminated in the first dmax bytes </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when src overlaps with dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d8b/strncat__s_8c.html#a8434f897dae0bd71d5c9fa330b53afa2" title="The strncat_s function appends a copy of the string pointed to by src (including the terminating null...">strncat_s()</a>, <a class="el" href="../../df/d8e/strcpy__s_8c.html#aa5d4bb11f2e2390d7d8bc0593f8c0b12" title="The strcpy_s function copies the string pointed to by src (including the terminating null character) ...">strcpy_s()</a>, <a class="el" href="../../d2/d68/strncpy__s_8c.html#a1554d39ed8b47634296e8fb86594f77e" title="The strncpy_s function copies not more than slen successive characters (characters that follow a null...">strncpy_s()</a> </dd></dl>

</div>
</div>
<a id="aadf29ab8687ac8eeeaacf6a577402dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf29ab8687ac8eeeaacf6a577402dd2">&#9670;&nbsp;</a></span>strcpy_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcpy_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strcpy_s function copies the string pointed to by src (including the terminating null character) into the array pointed to by dest. </p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written by strcpy_s in the array of dmax characters pointed to by dest are nulled when strcpy_s returns.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.1.3 The strcpy_s function (p: 615-616) <a href="http://en.cppreference.com/w/c/string/byte/strcpy">http://en.cppreference.com/w/c/string/byte/strcpy</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be replaced by src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string that will be copied to dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall be greater than strnlen_s(src, dmax). </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and destmax is greater than zero and not greater than RSIZE_MAX_STR, then strcpy_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, the characters in src were copied into dest and the result is null terminated. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest or src is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when strings overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dest &lt; src</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d81/strcat__s_8c.html#ad2ad89d442049cc8dd3683496df24a12" title="The strcat_s function appends a copy of the string pointed to by src (including the terminating null ...">strcat_s()</a>, <a class="el" href="../../df/d8b/strncat__s_8c.html#a8434f897dae0bd71d5c9fa330b53afa2" title="The strncat_s function appends a copy of the string pointed to by src (including the terminating null...">strncat_s()</a>, <a class="el" href="../../d2/d68/strncpy__s_8c.html#a1554d39ed8b47634296e8fb86594f77e" title="The strncpy_s function copies not more than slen successive characters (characters that follow a null...">strncpy_s()</a> </dd></dl>

</div>
</div>
<a id="a4975d61777c3b8e60885037bc27b9ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4975d61777c3b8e60885037bc27b9ab7">&#9670;&nbsp;</a></span>strncat_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strncat_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strncat_s function appends a copy of the string pointed to by src (including the terminating null character) to the end of the string pointed to by dest. </p>
<p>The initial character from src overwrites the null character at the end of dest.</p>
<p>All elements following the terminating null character (if any) written by strncat_s in the array of dmax characters pointed to by dest take unspecied values when strncat_s returns. With SAFECLIB_STR_NULL_SLACK defined the rest is cleared with NULL bytes.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.2.2 The strncat_s function (p: 618-620) <a href="http://en.cppreference.com/w/c/string/byte/strncat">http://en.cppreference.com/w/c/string/byte/strncat</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be extended by src if dmax allows. The string is null terminated. If the resulting concatenated string is less than dmax, the remaining slack space is nulled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of the resulting dest, including the null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string that will be concatenaed to string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum characters to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer </dd>
<dd>
dmax shall not equal zero </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR </dd>
<dd>
dmax shall be greater than strnlen_s(src,m). </dd>
<dd>
Copying shall not takeplace between objects that overlap</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_STR, then strncat_s sets dest[0] to the null character. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>successful operation, all the characters from src null terminated. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESUNTERM</td><td>when dest not terminated </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when src overlaps with dest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa198dc424193180e9bb0a13035c6cf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa198dc424193180e9bb0a13035c6cf5e">&#9670;&nbsp;</a></span>strncpy_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strncpy_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strncpy_s function copies not more than slen successive characters (characters that follow a null character are not copied) from the array pointed to by src to the array pointed to by dest. </p>
<p>If no null character was copied from src, then dest[n] is set to a null character.</p>
<p>All elements following the terminating null character (if any) written by strncpy_s in the array of dmax characters pointed to by dest take unspecied values when strncpy_s returns. With SAFECLIB_STR_NULL_SLACK defined the rest is cleared with NULL bytes.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): 7.21.2.4 The strncpy function (p: 326-327) <a href="http://en.cppreference.com/w/c/string/byte/strncpy">http://en.cppreference.com/w/c/string/byte/strncpy</a></li>
<li>ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be replaced by src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string that will be copied to dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>the maximum number of characters to copy from src</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dmax nor slen shall be equal to zero. </dd>
<dd>
Neither dmax nor slen shall be equal zero. </dd>
<dd>
Neither dmax nor slen shall be greater than RSIZE_MAX_STR. </dd>
<dd>
If slen is either greater than or equal to dmax, then dmax should be more than strnlen_s(src,dmax) to avoid truncation. </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax greater than RSIZE_MAX_STR, then strncpy_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>successful operation, the characters in src were copied to dest and the result is null terminated. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when strings overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dest &lt; src</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d81/strcat__s_8c.html#ad2ad89d442049cc8dd3683496df24a12" title="The strcat_s function appends a copy of the string pointed to by src (including the terminating null ...">strcat_s()</a>, <a class="el" href="../../df/d8b/strncat__s_8c.html#a8434f897dae0bd71d5c9fa330b53afa2" title="The strncat_s function appends a copy of the string pointed to by src (including the terminating null...">strncat_s()</a>, <a class="el" href="../../df/d8e/strcpy__s_8c.html#aa5d4bb11f2e2390d7d8bc0593f8c0b12" title="The strcpy_s function copies the string pointed to by src (including the terminating null character) ...">strcpy_s()</a>, <a class="el" href="../../dc/d4e/wcsncpy__s_8c.html#adaca642ca4a52f4e4b973489212fe2f0" title="The wcsncpy_s function copies the wide string pointed to by src (including the terminating null chara...">wcsncpy_s()</a> </dd></dl>

</div>
</div>
<a id="a97f0d069d4e184635b159849a1b99183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f0d069d4e184635b159849a1b99183">&#9670;&nbsp;</a></span>strnlen_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> strnlen_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strnlen_s function computes the length of the string pointed to by dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the string length, excluding the terminating null character. If dest is NULL, then strnlen_s returns 0. Otherwise, the strnlen_s function returns the number of characters that precede the terminating null character. If there is no null character in the first dmax characters of dest then strnlen_s returns dmax. At most the first dmax characters of dest are accessed by strnlen_s.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/de1/strnterminate__s_8c.html#ae2f83d56f2ec5cb219b7bc8961fb41b3" title="The strnterminate_s function will terminate the string if a null is not encountered before dmax chara...">strnterminate_s()</a> </dd></dl>

</div>
</div>
<a id="a3de538c8ac877750ba12b2c186fb375a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de538c8ac877750ba12b2c186fb375a">&#9670;&nbsp;</a></span>strtok_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> char* strtok_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **restrict&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of tokens, each of which is delimited by a character from the string pointed to by delim. </p>
<p>The fourth argument points to a caller-provided char pointer into which the strtok_s function stores information necessary for it to continue scanning the same string.</p>
<p>The first call in a sequence has a non-null first argument and dmax points to an object whose value is the number of elements in the character array pointed to by the first argument. The first call stores an initial value in the object pointed to by ptr and updates the value pointed to by dmax to reect the number of elements that remain in relation to ptr. Subsequent calls in the sequence have a null first argument and the objects pointed to by dmax and ptr are required to have the values stored by the previous call in the sequence, which are then updated. The separator string pointed to by delim may be different from call to call.</p>
<p>The first call in the sequence searches the string pointed to by dest for the first character that is not contained in the current separator string pointed to by delim. If no such character is found, then there are no tokens in the string pointed to by dest and the strtok_s function returns a null pointer. If such a character is found, it is the start of the first token.</p>
<p>The strtok_s function then searches from there for the first character in dest that is contained in the current separator string. If no such character is found, the current token extends to the end of the string pointed to by dest, and subsequent searches in the same string for a token return a null pointer. If such a character is found, it is overwritten by a null character, which terminates the current token.</p>
<p>In all cases, the strtok_s function stores sufcient information in the pointer pointed to by ptr so that subsequent calls, with a null pointer for dest and the unmodied pointer value for ptr, shall start searching just past the element overwritten by a null character (if any).</p>
<p>delim uses a STRTOK_DELIM_MAX_LEN of 16.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.3.1 The strtok_s function (p: 620-621) <a href="http://en.cppreference.com/w/c/string/byte/strok">http://en.cppreference.com/w/c/string/byte/strok</a></li>
<li>ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to tokenize </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dmax</td><td>restricted maximum length of dest string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>pointer to delimiter string (len &lt; 255) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>returned pointer to token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>delim shall not be a null pointer. </dd>
<dd>
ptr shall not be a null pointer. </dd>
<dd>
dmax shall not be a null pointer. </dd>
<dd>
*dmax shall not be 0. </dd>
<dd>
If dest is a null pointer, then *ptr shall not be a null pointer. </dd>
<dd>
dest must not be unterminated. </dd>
<dd>
The value of *dmax shall not be greater than RSIZE_MAX_STR. The end of the token found shall occur within the first *dmax characters of dest for the first call, and shall occur within the first *dmax characters of where searching resumes on subsequent calls. </dd>
<dd>
delim must not be longer than STRTOK_DELIM_MAX_LEN (default: 16).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The mingw MINGW_HAS_SECURE_API declares it without the dmax argument and without restrict. Skip it there. <code>char* strtok_s (char *str, const char *delim, char **ctx)</code></dd>
<dd>
C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The strtok_s function returns a pointer to the first character of a token; or a null pointer if there is no token or there is a runtime-constraint violation. Each call modifies dest by substituting a NULL character for the first delimiter that occurs after the returned token. If there is a runtime-constraint violation, the strtok_s function does not indirect through the dest/delim pointers, and does not store a value in the object pointed to by ptr.</dd></dl>
<p>errno is set to: ESNULLP when dest/delim/ptr is NULL pointer ESZEROL when *dmax = 0 ESLEMAX when *dmax &gt; RSIZE_MAX_STR ESUNTERM when unterminated string C11 just returns EINVAL</p>
<dl class="section remark"><dt>Remarks</dt><dd>Example to demonstrate usage of <a class="el" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s()</a> to tokenize a string <div class="fragment"><div class="line"><span class="comment">// Approach1: sequential strtok_s() calls</span></div><div class="line">str1 = <span class="stringliteral">&quot;,.:*one,two;three,;four*.*.five-six***&quot;</span>; <span class="comment">// String to tokenize </span></div><div class="line"><a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a> = 38;</div><div class="line">str2 = <span class="stringliteral">&quot;,.;*&quot;</span>; <span class="comment">// String of delimiters</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s</a>(str1, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str); </div><div class="line"><span class="comment">// token: one, remaining: two;three,;four*.*.five-six***, len: 30</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: two, remaining: three,;four*.*.five-six***, len: 26</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: three,  remaining: ;four*.*.five-six***, len: 20</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: four, remaining .*.five-six***, len: 14</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: five-six, remaining: **, len: 2</span></div><div class="line"></div><div class="line"> p2tok = <a class="code" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"> <span class="comment">// token: (null), remaining: **, len: 0</span></div><div class="line"></div><div class="line"> <span class="comment">// Approach2: Use of while loop with same entry data as used above</span></div><div class="line"> p2tok = str1;</div><div class="line"> <span class="keywordflow">while</span> (p2tok &amp;&amp; <a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>) </div><div class="line"> {</div><div class="line">   p2tok = <a class="code" href="../../d2/d46/strtok__s_8c.html#a48d68893518d61ffd8019234e8ed3dd5" title="A sequence of calls to the strtok_s function breaks the string pointed to by dest into a sequence of ...">strtok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line">   printf(<span class="stringliteral">&quot;  token --   remaining --  len=0 \n&quot;</span>, p2tok, p2str, (<span class="keywordtype">int</span>)<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a> );</div><div class="line"> }</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aafb56f5af9e3ad8eab7aad89b7756a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb56f5af9e3ad8eab7aad89b7756a9b">&#9670;&nbsp;</a></span>sprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int sprintf_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sprintf_s function composes a string with same test that would be printed if format was used on printf. </p>
<p>Instead of being printed, the content is stored in dest.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.6 The sprintf_s function (p: 595-596) <a href="http://en.cppreference.com/w/c/io/fprintf">http://en.cppreference.com/w/c/io/fprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>storage location for output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum number of characters to store in buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor fmt shall be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall be greater than strnlen_s(dest, dmax). </dd>
<dd>
fmt shall not contain the conversion specifier n. </dd>
<dd>
None of the arguments corresponding to s is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If no runtime-constraint violation occurred, the <code>sprintf_s</code> function returns the number of characters written in the array, not counting the terminating null character. If an encoding error occurred, <code>sprintf_s</code> returns a negative value. If any other runtime- constraint violation in <code>vsnprintf</code> occurred, <code>sprintf_s</code> returns zero. </dd>
<dd>
If the buffer dest is too small for the formatted text, including the terminating null, then the buffer is set to an empty string by placing a null character at dest[0], and the invalid parameter handler is invoked. Unlike _snprintf, sprintf_s guarantees that the buffer will be null-terminated unless the buffer size is zero.</dd></dl>
<p>errno: ESNULLP when <code>dest/fmt</code> is NULL pointer ESZEROL when <code>dmax</code> = 0 ESLEMAX when <code>dmax</code> &gt; <code>RSIZE_MAX_STR</code> ESNOSPC when return value exceeds dmax EINVAL when <code>fmt</code> contains <code>n</code> </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if an encoding error occurred or the return buffer size exceeds dmax. </td></tr>
    <tr><td class="paramname">0</td><td>on some other error in <code>vsnprintf()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b9e1e5e6322ca4bf8cb5b1d6352a2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9e1e5e6322ca4bf8cb5b1d6352a2e7">&#9670;&nbsp;</a></span>vsprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vsprintf_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vsprintf_s</code> function composes a string with same test that would be printed if format was used on <code>printf</code>. </p>
<p>Instead of being printed, the content is stored in dest. With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written by vsprintf_s in the array of <code>dmax</code> characters pointed to by dest are nulled when <code>vsprintf_s</code> returns.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.13 The vsprintf_s function (p: 601) <a href="http://en.cppreference.com/w/c/io/vfprintf">http://en.cppreference.com/w/c/io/vfprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor fmt shall be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall be greater than strnlen_s(dest, dmax). </dd>
<dd>
fmt shall not contain the conversion specifier n </dd>
<dd>
None of the arguments corresponding to s is a null pointer </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd>
<dd>
If the buffer dest is too small for the formatted text, including the terminating null, then the buffer is set to an empty string by placing a null character at dest[0], and the invalid parameter handler is invoked. Unlike vsnprintf, vsprintf_s guarantees that the buffer will be null-terminated unless the buffer size is zero.</dd></dl>
<p>errno: ESNULLP when <code>dest/fmt</code> is NULL pointer ESZEROL when <code>dmax</code> = 0 ESLEMAX when <code>dmax</code> &gt; <code>RSIZE_MAX_STR</code> ESNOSPC when return value exceeds dmax EINVAL when <code>fmt</code> contains <code>n</code> </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if an encoding error occurred or the return buffer size exceeds dmax. </td></tr>
    <tr><td class="paramname">0</td><td>on some other error in <code>vsnprintf()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d21/sprintf__s_8c.html#a2d098650aa785e976422266d4daf1682" title="The sprintf_s function composes a string with same test that would be printed if format was used on p...">sprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="ae48680eec2d6383a40b479234979a045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48680eec2d6383a40b479234979a045">&#9670;&nbsp;</a></span>snprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int snprintf_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The truncating <code>snprintf_s</code> function composes a string with same test that would be printed if format was used on <code>printf</code>. </p>
<p>Instead of being printed, the content is stored in dest. More than dmax - 1 characters might be written, so this variant is <b>unsafe!</b> Always use <b>sprintf_s</b> instead. The resulting character string will be terminated with a null character, unless <code>dmax</code> is zero. If <code>dmax</code> is zero, nothing is written and <code>dest</code> may be a null pointer, however the return value (number of bytes that would be written) is still calculated and returned. Warning: Unlike the safe variant <code>sprintf_s</code>, <code>snprintf_s</code> does not guarantee that the buffer will be null-terminated unless the buffer size is zero.</p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vsnprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.6 The snprintf_s function (p: 594-595) <a href="http://en.cppreference.com/w/c/io/fprintf">http://en.cppreference.com/w/c/io/fprintf</a></li>
<li>only included in safeclib with <code>&ndash;enable-unsafe</code> </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>dest</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>dmax</code> shall not be greater than <code>RSIZE_MAX_STR</code>. </dd>
<dd>
<code>dmax</code> shall not equal zero. </dd>
<dd>
<code>dmax</code> shall be greater than <code>strnlen_s(dest, dmax)</code>. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code>. </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters not including the terminating null character (which is always written as long as buffer is not a null pointer and <code>dmax</code> is not zero and not greater than <code>RSIZE_MAX_STR</code>), which would have been written to <code>dest</code> if <code>dmax</code> was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when <code>dest/fmt</code> is NULL pointer </td></tr>
    <tr><td class="paramname">-ESZEROL</td><td>when <code>dmax</code> = 0 </td></tr>
    <tr><td class="paramname">-ESLEMAX</td><td>when <code>dmax</code> &gt; <code>RSIZE_MAX_STR</code> </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when <code>fmt</code> contains n</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d21/sprintf__s_8c.html#a2d098650aa785e976422266d4daf1682" title="The sprintf_s function composes a string with same test that would be printed if format was used on p...">sprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a76247677ead8dabafadb6fc6d9ce4346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76247677ead8dabafadb6fc6d9ce4346">&#9670;&nbsp;</a></span>vsnprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vsnprintf_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The truncating <code>vsnprintf_s</code> function composes a string with same test that would be printed if format was used on <code>printf</code>. </p>
<p>Instead of being printed, the content is stored in dest. Warning: Unlike the safe variant <code>vsprintf_s</code>, <code>vsnprintf_s</code> does not guarantee that the buffer will be null-terminated unless the buffer size is zero. More than dmax - 1 characters might be written!</p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vsnprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.12 The vsnprintf_s function (p: 600) <a href="http://en.cppreference.com/w/c/io/vfprintf">http://en.cppreference.com/w/c/io/vfprintf</a></li>
<li>only included in safeclib with <code>&ndash;enable-unsafe</code> </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>dest</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>dmax</code> shall not be greater than <code>RSIZE_MAX_STR</code>. </dd>
<dd>
<code>dmax</code> shall not equal zero. </dd>
<dd>
<code>dmax</code> shall be greater than <code>strnlen_s(dest, dmax)</code>. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code>. </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd>
<dd>
If the buffer <code>dest</code> is too small for the formatted text, including the terminating null, then the buffer is set to an empty string by placing a null character at <code>dest</code>[0], and the invalid parameter handler is invoked. Unlike <code>vsnprintf</code>, <code>vsprintf_s</code> guarantees that the buffer will be null-terminated unless the buffer size is zero.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when <code>dest/fmt</code> is NULL pointer </td></tr>
    <tr><td class="paramname">-ESZEROL</td><td>when <code>dmax</code> = 0 </td></tr>
    <tr><td class="paramname">-ESLEMAX</td><td>when <code>dmax</code> &gt; <code>RSIZE_MAX_STR</code> </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d21/sprintf__s_8c.html#a2d098650aa785e976422266d4daf1682" title="The sprintf_s function composes a string with same test that would be printed if format was used on p...">sprintf_s()</a>, <a class="el" href="../../d1/df7/vsprintf__s_8c.html#a1df253dd774c8386f23a3b5fd10f9485" title="The vsprintf_s function composes a string with same test that would be printed if format was used on ...">vsprintf_s()</a> </dd></dl>

</div>
</div>
<a id="ad8b8a36709f6474c620d369e70b2309c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b8a36709f6474c620d369e70b2309c">&#9670;&nbsp;</a></span>sscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int sscanf_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>sscanf_s</code> function reads a formatted string, and writes to a list of arguments. </p>
<p>Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.7 The sscanf_s function (p: 596) <a href="http://en.cppreference.com/w/c/io/fscanf">http://en.cppreference.com/w/c/io/fscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to a null-terminated string to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>buffer</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>c</code> into a single character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d4d/vsscanf__s_8c.html#a677b9ed908b8e07f51880d3652ae6811" title="The vsscanf_s function reads a formatted string, and writes to a list of arguments. ">vsscanf_s()</a>, <a class="el" href="../../d8/da1/swscanf__s_8c.html#affe7ffdfc68b3892c254ebb60234dfe0" title="The swscanf_s function reads a formatted wide string. ">swscanf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a4d4672e26e1f04843286f468a3c96afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4672e26e1f04843286f468a3c96afe">&#9670;&nbsp;</a></span>fscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int fscanf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>fscanf_s</code> function reads a formatted string from a buffered FILE stream, and writes to a list of arguments. </p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.2 The fscanf_s function (p: 592-593) <a href="http://en.cppreference.com/w/c/io/fscanf">http://en.cppreference.com/w/c/io/fscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>pointer to a FILE stream to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>stream</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>c</code> into a single character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/dc6/vfscanf__s_8c.html#aef1fd4b362dea57c39b75e17ac31d0af" title="The vfscanf_s function reads a formatted string from a buffered FILE stream, and writes to a list of ...">vfscanf_s()</a>, <a class="el" href="../../d3/d42/fwscanf__s_8c.html#a980109ae08a082f7658918f49bb9be16" title="The fwscanf_s function reads a formatted wide string. ">fwscanf_s()</a>, <a class="el" href="../../d0/dad/scanf__s_8c.html#a840cbd850ba8cf5b2b53a4dea464cff7" title="The scanf_s function reads a formatted string from stdin, and writes to a list of arguments...">scanf_s()</a> </dd></dl>

</div>
</div>
<a id="ae9efcc59a87e6ea1fa8aaccb2f4c9a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9efcc59a87e6ea1fa8aaccb2f4c9a00">&#9670;&nbsp;</a></span>scanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int scanf_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>scanf_s</code> function reads a formatted string from stdin, and writes to a list of arguments. </p>
<p>Reaching the end of the io buffer is equivalent to reaching the end-of-file condition for <code>fscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.4 The scanf_s function (p: 594) <a href="http://en.cppreference.com/w/c/io/fscanf">http://en.cppreference.com/w/c/io/fscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>c</code> into a single character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d4d/vsscanf__s_8c.html#a677b9ed908b8e07f51880d3652ae6811" title="The vsscanf_s function reads a formatted string, and writes to a list of arguments. ">vsscanf_s()</a>, <a class="el" href="../../d8/da1/swscanf__s_8c.html#affe7ffdfc68b3892c254ebb60234dfe0" title="The swscanf_s function reads a formatted wide string. ">swscanf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a792ab2d328b832d40618b9cae17b97d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792ab2d328b832d40618b9cae17b97d5">&#9670;&nbsp;</a></span>vscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vscanf_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vscanf_s</code> function reads a formatted string from stdin, and writes to a list of arguments. </p>
<p>Reaching the end of the io buffer is equivalent to reaching the end-of-file condition for <code>fscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.11 The vscanf_s function (p: 599) <a href="http://en.cppreference.com/w/c/io/vfscanf">http://en.cppreference.com/w/c/io/vfscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ap</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>c</code> into a single character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/dc6/vfscanf__s_8c.html#aef1fd4b362dea57c39b75e17ac31d0af" title="The vfscanf_s function reads a formatted string from a buffered FILE stream, and writes to a list of ...">vfscanf_s()</a>, <a class="el" href="../../d0/dad/scanf__s_8c.html#a840cbd850ba8cf5b2b53a4dea464cff7" title="The scanf_s function reads a formatted string from stdin, and writes to a list of arguments...">scanf_s()</a>, <a class="el" href="../../d4/d4d/vsscanf__s_8c.html#a677b9ed908b8e07f51880d3652ae6811" title="The vsscanf_s function reads a formatted string, and writes to a list of arguments. ">vsscanf_s()</a> </dd></dl>

</div>
</div>
<a id="a8ffe4d0267945bca8be68ca277c86776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffe4d0267945bca8be68ca277c86776">&#9670;&nbsp;</a></span>vfscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vfscanf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vfscanf_s</code> function reads a formatted string from a buffered FILE stream, and writes to a list of arguments. </p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.9 The vfscanf_s function (p: 597-598) <a href="http://en.cppreference.com/w/c/io/vfscanf">http://en.cppreference.com/w/c/io/vfscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>pointer to a FILE stream to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ap</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>stream</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>c</code> into a single character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>vvfscanf_s(), <a class="el" href="../../d3/d42/fwscanf__s_8c.html#a980109ae08a082f7658918f49bb9be16" title="The fwscanf_s function reads a formatted wide string. ">fwscanf_s()</a>, <a class="el" href="../../d0/dad/scanf__s_8c.html#a840cbd850ba8cf5b2b53a4dea464cff7" title="The scanf_s function reads a formatted string from stdin, and writes to a list of arguments...">scanf_s()</a> </dd></dl>

</div>
</div>
<a id="ada8531e105a7c7eaf7a0758c0657d6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8531e105a7c7eaf7a0758c0657d6eb">&#9670;&nbsp;</a></span>vsscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vsscanf_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vsscanf_s</code> function reads a formatted string, and writes to a list of arguments. </p>
<p>Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.14 The vsscanf_s function (p: 602) <a href="http://en.cppreference.com/w/c/io/vfscanf">http://en.cppreference.com/w/c/io/vfscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to a null-terminated string to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ap</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>buffer</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>c</code> into a single character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>vvsscanf_s(), <a class="el" href="../../d8/da1/swscanf__s_8c.html#affe7ffdfc68b3892c254ebb60234dfe0" title="The swscanf_s function reads a formatted wide string. ">swscanf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a460a1d3364e991ee9f36b6dca7ee77d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460a1d3364e991ee9f36b6dca7ee77d6">&#9670;&nbsp;</a></span>printf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int printf_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The printf_s function composes a string via the format string and writes it to a FILE buffer. </p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.3 The printf_s function (p: 593-594) <a href="http://en.cppreference.com/w/c/io/fprintf">http://en.cppreference.com/w/c/io/fprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>fmt shall not be a null pointer. </dd>
<dd>
fmt shall not contain the conversion specifier n. </dd>
<dd>
None of the arguments corresponding to s is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>on some other error. errno is set then. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89ed5ca61e0290bc13131951a27307e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ed5ca61e0290bc13131951a27307e9">&#9670;&nbsp;</a></span>fprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int fprintf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The fprintf_s function composes a string via the format string and writes it to a FILE buffer. </p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vfprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.1 The fprintf_s function (p: 591) <a href="http://en.cppreference.com/w/c/io/fprintf">http://en.cppreference.com/w/c/io/fprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>output file stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither stream nor fmt shall be a null pointer. </dd>
<dd>
fmt shall not contain the conversion specifier n. </dd>
<dd>
None of the arguments corresponding to s is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when stream/fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>on some other error. errno is set then. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cb9c5161658cd52484b66eb60a18538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb9c5161658cd52484b66eb60a18538">&#9670;&nbsp;</a></span>vprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vprintf_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The vprintf_s function composes a string via the format string and writes it to a FILE buffer. </p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.10 The vprintf_s function (p: 599-599) <a href="http://en.cppreference.com/w/c/io/vfprintf">http://en.cppreference.com/w/c/io/vfprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>fmt shall not be a null pointer. </dd>
<dd>
fmt shall not contain the conversion specifier n. </dd>
<dd>
None of the arguments corresponding to s is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>on some other error. errno is set then. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b2bb4f72487b4eafac78d110334b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b2bb4f72487b4eafac78d110334b9f">&#9670;&nbsp;</a></span>vfprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vfprintf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The vfprintf_s function composes a string via the format string and writes it to a FILE buffer. </p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vfprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.5.3.8 The vfprintf_s function (p: 597) <a href="http://en.cppreference.com/w/c/io/vfprintf">http://en.cppreference.com/w/c/io/vfprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>output file stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither stream nor fmt shall be a null pointer. </dd>
<dd>
fmt shall not contain the conversion specifier n. </dd>
<dd>
None of the arguments corresponding to s is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when stream/fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>on some other error. errno is set then. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f77e79ac9977b72ef64a94f3f70fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f77e79ac9977b72ef64a94f3f70fc2">&#9670;&nbsp;</a></span>strerror_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strerror_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">errno_t&#160;</td>
          <td class="paramname"><em>errnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>strerror_s</code> function returns a pointer to the textual description of the system error code errnum, identical to the description that would be printed by perror(). </p>
<p>In addition to <code>strerror()</code> it adds the size of the destination array in order to prevent buffer overflow, and it truncates overlong error messages with "...".</p>
<p>No more than bufsz-1 bytes are written, the buffer is always null-terminated. If the message had to be truncated to fit the buffer and bufsz is greater than 3, then only bufsz-4 bytes are written, and the characters "..." are appended before the null terminator. The behavior is undefined if writing to dest occurs past the end of the array, which can happen when the size of the buffer pointed to by dest is less than the number of characters in the error message which in turn is less than dmax.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.4.2 The strerror_s function (p: 622) <a href="http://en.cppreference.com/w/c/byte/strerror">http://en.cppreference.com/w/c/byte/strerror</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to a user-provided buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errnum</td><td>integer value referring to an error code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
dmax shall not equal zero.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the entire message was successfully stored in dest, non-zero otherwise. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on success </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESLEMIN</td><td>when the result would be longer than 4 and dmax &lt; 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d02/strerror__s_8c.html#a3f6ed5e17ae53f1dd3b4527d3111c6fc" title="The strerrorlen_s function returns the untruncated length of the textual description of the system er...">strerrorlen_s()</a> </dd></dl>

</div>
</div>
<a id="afaf218acae58eaeb99428cbe2f9fe7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf218acae58eaeb99428cbe2f9fe7d3">&#9670;&nbsp;</a></span>strerrorlen_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> size_t strerrorlen_s </td>
          <td>(</td>
          <td class="paramtype">errno_t&#160;</td>
          <td class="paramname"><em>errnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>strerrorlen_s</code> function returns the untruncated length of the textual description of the system error code <code>errnum</code>, identical to the description that would be printed by <code>perror()</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.4.2 The strerrorlen_s function (p: 622) <a href="http://en.cppreference.com/w/c/byte/strerror">http://en.cppreference.com/w/c/byte/strerror</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errnum</td><td>integer value referring to an error code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the error message or 0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d02/strerror__s_8c.html#a62f8350a28021362c72a0fb816c0f517" title="The strerror_s function returns a pointer to the textual description of the system error code errnum...">strerror_s()</a> </dd></dl>

</div>
</div>
<a id="a3ad0da7c4fe04e8800a1eef2d9bda3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad0da7c4fe04e8800a1eef2d9bda3ec">&#9670;&nbsp;</a></span>strcmp_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcmp_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares string src to string dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indicator</td><td>pointer to result indicator, greater than 0, equal to 0 or less than 0, if the string pointed to by dest is greater than, equal to or less than the string pointed to by src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>indicator (when the return code is OK) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>when dest greater than src </td></tr>
    <tr><td class="paramname">0</td><td>when strings the same </td></tr>
    <tr><td class="paramname">&lt;0</td><td>when dest less than src </td></tr>
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/indicator is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d7c/strcasecmp__s_8c.html#ae11b6060ef450062df8082045083bec1" title="Case insensitive string comparison by converting to uppercase prior to the compare. ">strcasecmp_s()</a> </dd></dl>

</div>
</div>
<a id="a1fe094189ed7156185c78d3180cd522d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe094189ed7156185c78d3180cd522d">&#9670;&nbsp;</a></span>strcasecmp_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcasecmp_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case insensitive string comparison by converting to uppercase prior to the compare. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indicator</td><td>pointer to result indicator, greater than 0, equal to 0 or less than 0, if the string pointed to by dest is greater than, equal to or less than the string pointed to by src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>indicator (when the return code is OK) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>when dest greater than src </td></tr>
    <tr><td class="paramname">0</td><td>when strings the same </td></tr>
    <tr><td class="paramname">&lt;0</td><td>when dest less than src </td></tr>
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/indicator is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d7b/strcmp__s_8c.html#a1af73c8a0a8e2f7abc5a1a78f154fa8e" title="Compares string src to string dest. ">strcmp_s()</a> </dd></dl>

</div>
</div>
<a id="a2b38f74261dd0bb20957346dd8e25113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b38f74261dd0bb20957346dd8e25113">&#9670;&nbsp;</a></span>strcasestr_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcasestr_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="../../d6/d9e/strcasestr__s_8c.html#afaeb24871b940cfc3091c9fff24d4226" title="The strcasestr_s() function locates the first occurrence of the substring pointed to by src which wou...">strcasestr_s()</a> function locates the first occurrence of the substring pointed to by src which would be located in the string pointed to by dest. </p>
<p>The comparison is case insensitive.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to be searched for the substring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the sub string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum length of src string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">substring</td><td>returned pointer to the substring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
Neither dmax nor slen shall equal zero. </dd>
<dd>
Neither dmax nor slen shall be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, substring found. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dst/src/substring is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when substring not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a>, <a class="el" href="../../d2/d9c/strprefix__s_8c.html#a6348bed5e142178bf8fb623adc82c48d" title="Determines if the prefix pointed to by src is at the beginning of string pointed to by dest...">strprefix_s()</a> </dd></dl>

</div>
</div>
<a id="a6f913eed185743b3eaab5fbb8096eea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f913eed185743b3eaab5fbb8096eea7">&#9670;&nbsp;</a></span>strcmpfld_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcmpfld_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the character array pointed to by src to the character array pointed to by dest for dmax characters. </p>
<p>The null terminator does not stop the comparison.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indicator</td><td>pointer to result indicator, greater than 0, equal to 0 or less than 0, if the string pointed to by dest is greater than, equal to or less than the string pointed to by src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>indicator (when the return code is OK) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>when dest greater than src </td></tr>
    <tr><td class="paramname">0</td><td>when strings the same </td></tr>
    <tr><td class="paramname">&lt;0</td><td>when dest less than src </td></tr>
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/indicator is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d38/strcpyfld__s_8c.html#ab1ef30c509655a53db8b4ba86dde59da" title="The strcpyfld_s function copies slen characters from the character array pointed to by src into the c...">strcpyfld_s()</a>, <a class="el" href="../../db/def/strcpyfldin__s_8c.html#aa400259d7a9ef29bdcc0c7410cfdb255" title="The strcpyfldin_s function copies at most slen characters from the null terminated string pointed to ...">strcpyfldin_s()</a>, <a class="el" href="../../d1/dae/strcpyfldout__s_8c.html#aa7c806c65deea2d60540853bcf95a435" title="The strcpyfldout_s function copies slen characters from the character array pointed to by src into th...">strcpyfldout_s()</a> </dd></dl>

</div>
</div>
<a id="adcaf439efea9f06742b98ad766a78727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaf439efea9f06742b98ad766a78727">&#9670;&nbsp;</a></span>strcpyfld_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcpyfld_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>strcpyfld_s</code> function copies <code>slen</code> characters from the character array pointed to by <code>src</code> into the character array pointed to by <code>dest</code>. </p>
<p>The copy operation does not stop on the null character as the function copies <code>slen</code> characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be replaced by src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the character array that will be copied to dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum length of src</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
slen shall not equal zero. </dd>
<dd>
slen shall not exceed dmax </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and destmax is greater than zero and not greater than RSIZE_MAX_STR, then strcpyfld_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when strings overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax &lt; slen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/def/strcpyfldin__s_8c.html#aa400259d7a9ef29bdcc0c7410cfdb255" title="The strcpyfldin_s function copies at most slen characters from the null terminated string pointed to ...">strcpyfldin_s()</a>, <a class="el" href="../../d1/dae/strcpyfldout__s_8c.html#aa7c806c65deea2d60540853bcf95a435" title="The strcpyfldout_s function copies slen characters from the character array pointed to by src into th...">strcpyfldout_s()</a> </dd></dl>

</div>
</div>
<a id="ad63973653160bd3141f4648b58f3ae64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63973653160bd3141f4648b58f3ae64">&#9670;&nbsp;</a></span>strcpyfldin_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcpyfldin_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strcpyfldin_s function copies at most slen characters from the null terminated string pointed to by src into the fixed character array pointed to by dest. </p>
<p>The copy operation stops on the null character if encountered and then continues to fill the field with nulls up to dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be replaced by src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the null terminated string that will be copied into the character array pointed to by dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum length of src</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
slen shall not equal zero. </dd>
<dd>
slen shall not exceed dmax </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_STR, then strcpyfldin_s nulls dest </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when strings overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax &lt; slen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d38/strcpyfld__s_8c.html#ab1ef30c509655a53db8b4ba86dde59da" title="The strcpyfld_s function copies slen characters from the character array pointed to by src into the c...">strcpyfld_s()</a>, <a class="el" href="../../d1/dae/strcpyfldout__s_8c.html#aa7c806c65deea2d60540853bcf95a435" title="The strcpyfldout_s function copies slen characters from the character array pointed to by src into th...">strcpyfldout_s()</a>, </dd></dl>

</div>
</div>
<a id="a93d8620276c0317f0cc87fb55741475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d8620276c0317f0cc87fb55741475b">&#9670;&nbsp;</a></span>strcpyfldout_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcpyfldout_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strcpyfldout_s function copies slen characters from the character array pointed to by src into the string pointed to by dest. </p>
<p>A null is included to properly termiante the dest string. The copy operation does not stop on the null character as function copies dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be replaced by src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the character array to be copied to dest and null terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>the maximum number of characters that will be copied from the src field into the dest string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
slen shall not equal zero. </dd>
<dd>
slen shall not exceed dmax </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_STR, then strcpyfldout_s nulls dest </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when strings overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax &lt; slen </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d38/strcpyfld__s_8c.html#ab1ef30c509655a53db8b4ba86dde59da" title="The strcpyfld_s function copies slen characters from the character array pointed to by src into the c...">strcpyfld_s()</a>, <a class="el" href="../../db/def/strcpyfldin__s_8c.html#aa400259d7a9ef29bdcc0c7410cfdb255" title="The strcpyfldin_s function copies at most slen characters from the null terminated string pointed to ...">strcpyfldin_s()</a> </dd></dl>

</div>
</div>
<a id="a5df8f61f2b3c5c2f7a7295ca79853828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df8f61f2b3c5c2f7a7295ca79853828">&#9670;&nbsp;</a></span>strcspn_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcspn_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the prefix length of the string pointed to by dest which consists entirely of characters that are excluded from the string pointed to by src. </p>
<p>The scanning stops at the first null in dest or after dmax characters. The exclusion string is checked to the null or after slen characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to determine the prefix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to exclusion string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>restricted maximum length of string src </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>pointer to a count variable that will be updated with the dest substring length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
count shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when operation is successful </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/count is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/df1/strspn__s_8c.html#a88170b384d5975577bb20c898bdc6c5d" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strspn_s()</a>, <a class="el" href="../../de/dd3/strpbrk__s_8c.html#ab7cdbee62fb36f9883dbc4eb7a9629a0" title="Returns a pointer, first, to the first ocurrence of any character in src which is contained in dest...">strpbrk_s()</a>, <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a> </dd></dl>

</div>
</div>
<a id="a47a970d738ad33ab4d193a0f00a970a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a970d738ad33ab4d193a0f00a970a9">&#9670;&nbsp;</a></span>strfirstchar_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strfirstchar_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a pointer to the first occurrence of character c in dest. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to locate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first</td><td>returned pointer to first occurrence of c</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
first shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to first occurence of c, NULL if not found </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when pointer to first occurrence is returned </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dst/first is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/d19/strlastchar__s_8c.html#a467f98690a5729be9d4ea0c620147cf9" title="Returns a pointer to the last occurrence of character c in dest. ">strlastchar_s()</a>, <a class="el" href="../../de/d3e/strfirstdiff__s_8c.html#a8de98455a2e24d2da4911cbd19d56d8e" title="Returns the index of the first character that is different between dest and src. ">strfirstdiff_s()</a>, <a class="el" href="../../d5/d5e/strfirstsame__s_8c.html#a489bc1f6ad88c01073f128cad2a45d1f" title="Returns the index of the first character that is the same between dest and src. ">strfirstsame_s()</a>, <a class="el" href="../../d9/dfe/strlastdiff__s_8c.html#a11e1abfe1dae56e7a198c19e6c1c6dc5" title="Returns the index of the last character that is different between dest and src. ">strlastdiff_s()</a>, <a class="el" href="../../da/db5/strlastsame__s_8c.html#afc7a385ce2e44ee19042af09fc0ce36f" title="Returns the index of the last character that is the same between dest and src. ">strlastsame_s()</a>, </dd></dl>

</div>
</div>
<a id="aafc5d71409ea37130532458a4abd360c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc5d71409ea37130532458a4abd360c">&#9670;&nbsp;</a></span>strfirstdiff_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strfirstdiff_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the first character that is different between dest and src. </p>
<p>Index is valid only for OK. The scanning stops at the first null in dest or src, or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>pointer to returned index to first difference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>index to first difference, when the return code is OK </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when index to first diff is returned </td></tr>
    <tr><td class="paramname">ESNODIFF</td><td>when no difference </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/index is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d01/strfirstchar__s_8c.html#a72b0c60fced8d289a6adcb11b0516217" title="This function returns a pointer to the first occurrence of character c in dest. ">strfirstchar_s()</a>, <a class="el" href="../../d5/d5e/strfirstsame__s_8c.html#a489bc1f6ad88c01073f128cad2a45d1f" title="Returns the index of the first character that is the same between dest and src. ">strfirstsame_s()</a>, <a class="el" href="../../d7/d19/strlastchar__s_8c.html#a467f98690a5729be9d4ea0c620147cf9" title="Returns a pointer to the last occurrence of character c in dest. ">strlastchar_s()</a>, <a class="el" href="../../d9/dfe/strlastdiff__s_8c.html#a11e1abfe1dae56e7a198c19e6c1c6dc5" title="Returns the index of the last character that is different between dest and src. ">strlastdiff_s()</a>, <a class="el" href="../../da/db5/strlastsame__s_8c.html#afc7a385ce2e44ee19042af09fc0ce36f" title="Returns the index of the last character that is the same between dest and src. ">strlastsame_s()</a> </dd></dl>

</div>
</div>
<a id="a9548290da70633c318f4583cbaf96d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9548290da70633c318f4583cbaf96d5e">&#9670;&nbsp;</a></span>strisalphanumeric_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strisalphanumeric_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the entire string contains alphanumerics. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when dest is alphanumeric </dd>
<dd>
false when dest is not alphanumeric or an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dd0/strisascii__s_8c.html#a7ed626fac212e28529a076a1338a2d3d" title="This function checks if the entire string contains ascii characters. ">strisascii_s()</a>, <a class="el" href="../../da/db8/strisdigit__s_8c.html#af6d2b2392726a66476a6479842142679" title="This function checks that the entire string contains digits. ">strisdigit_s()</a>, <a class="el" href="../../d1/d33/strishex__s_8c.html#a4ea325a1dbaee49509ed759dc12b41e1" title="This function checks that the entire string contains hex characters. ">strishex_s()</a>, <a class="el" href="../../de/d5b/strislowercase__s_8c.html#a821e868be7e53a143217aac37f29b971" title="This function checks if entire string is lowercase. ">strislowercase_s()</a>, <a class="el" href="../../d7/d8d/strismixedcase__s_8c.html#a48432b5227c0482f5a4f9007b9a91e62" title="This function checks that the entire string is mixed case. ">strismixedcase_s()</a>, <a class="el" href="../../dd/d9f/strisuppercase__s_8c.html#a75fd0f3c25590af5a836afe1fca4db16" title="This function checks if entire string is uppercase The scanning stops at the first null or after dmax...">strisuppercase_s()</a> </dd></dl>

</div>
</div>
<a id="a526dd1c60bc2eef022c4743566203c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526dd1c60bc2eef022c4743566203c38">&#9670;&nbsp;</a></span>strisascii_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strisascii_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the entire string contains ascii characters. </p>
<p>The scanning stops at the first null or at most dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when string is ascii </dd>
<dd>
false when string contains one or more non-ascii or an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dc9/strisalphanumeric__s_8c.html#a67d621438c8b718945ef21e65351eef6" title="This function checks if the entire string contains alphanumerics. ">strisalphanumeric_s()</a>, <a class="el" href="../../da/db8/strisdigit__s_8c.html#af6d2b2392726a66476a6479842142679" title="This function checks that the entire string contains digits. ">strisdigit_s()</a>, <a class="el" href="../../d1/d33/strishex__s_8c.html#a4ea325a1dbaee49509ed759dc12b41e1" title="This function checks that the entire string contains hex characters. ">strishex_s()</a>, <a class="el" href="../../de/d5b/strislowercase__s_8c.html#a821e868be7e53a143217aac37f29b971" title="This function checks if entire string is lowercase. ">strislowercase_s()</a>, <a class="el" href="../../d7/d8d/strismixedcase__s_8c.html#a48432b5227c0482f5a4f9007b9a91e62" title="This function checks that the entire string is mixed case. ">strismixedcase_s()</a>, <a class="el" href="../../dd/d9f/strisuppercase__s_8c.html#a75fd0f3c25590af5a836afe1fca4db16" title="This function checks if entire string is uppercase The scanning stops at the first null or after dmax...">strisuppercase_s()</a> </dd></dl>

</div>
</div>
<a id="a5d385633458d767bd9beacf413c4c7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d385633458d767bd9beacf413c4c7ec">&#9670;&nbsp;</a></span>strisdigit_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strisdigit_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks that the entire string contains digits. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR..</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when string is digit </dd>
<dd>
false when string is not digit or an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dc9/strisalphanumeric__s_8c.html#a67d621438c8b718945ef21e65351eef6" title="This function checks if the entire string contains alphanumerics. ">strisalphanumeric_s()</a>, <a class="el" href="../../d8/dd0/strisascii__s_8c.html#a7ed626fac212e28529a076a1338a2d3d" title="This function checks if the entire string contains ascii characters. ">strisascii_s()</a>, <a class="el" href="../../d1/d33/strishex__s_8c.html#a4ea325a1dbaee49509ed759dc12b41e1" title="This function checks that the entire string contains hex characters. ">strishex_s()</a>, <a class="el" href="../../de/d5b/strislowercase__s_8c.html#a821e868be7e53a143217aac37f29b971" title="This function checks if entire string is lowercase. ">strislowercase_s()</a>, <a class="el" href="../../d7/d8d/strismixedcase__s_8c.html#a48432b5227c0482f5a4f9007b9a91e62" title="This function checks that the entire string is mixed case. ">strismixedcase_s()</a>, <a class="el" href="../../dd/d9f/strisuppercase__s_8c.html#a75fd0f3c25590af5a836afe1fca4db16" title="This function checks if entire string is uppercase The scanning stops at the first null or after dmax...">strisuppercase_s()</a> </dd></dl>

</div>
</div>
<a id="aebd555b3e2569803c5d75016f70124aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd555b3e2569803c5d75016f70124aa">&#9670;&nbsp;</a></span>strishex_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strishex_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks that the entire string contains hex characters. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when string is hex </dd>
<dd>
false when string is not hex or an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dc9/strisalphanumeric__s_8c.html#a67d621438c8b718945ef21e65351eef6" title="This function checks if the entire string contains alphanumerics. ">strisalphanumeric_s()</a>, <a class="el" href="../../d8/dd0/strisascii__s_8c.html#a7ed626fac212e28529a076a1338a2d3d" title="This function checks if the entire string contains ascii characters. ">strisascii_s()</a>, <a class="el" href="../../da/db8/strisdigit__s_8c.html#af6d2b2392726a66476a6479842142679" title="This function checks that the entire string contains digits. ">strisdigit_s()</a>, <a class="el" href="../../de/d5b/strislowercase__s_8c.html#a821e868be7e53a143217aac37f29b971" title="This function checks if entire string is lowercase. ">strislowercase_s()</a>, <a class="el" href="../../d7/d8d/strismixedcase__s_8c.html#a48432b5227c0482f5a4f9007b9a91e62" title="This function checks that the entire string is mixed case. ">strismixedcase_s()</a>, <a class="el" href="../../dd/d9f/strisuppercase__s_8c.html#a75fd0f3c25590af5a836afe1fca4db16" title="This function checks if entire string is uppercase The scanning stops at the first null or after dmax...">strisuppercase_s()</a> </dd></dl>

</div>
</div>
<a id="a20c94eb45ded60347733f23a6d239e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c94eb45ded60347733f23a6d239e32">&#9670;&nbsp;</a></span>strislowercase_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strislowercase_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if entire string is lowercase. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dest shall be a null terminated. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when string is lowercase </dd>
<dd>
false when string is not lowercase or an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dc9/strisalphanumeric__s_8c.html#a67d621438c8b718945ef21e65351eef6" title="This function checks if the entire string contains alphanumerics. ">strisalphanumeric_s()</a>, <a class="el" href="../../d8/dd0/strisascii__s_8c.html#a7ed626fac212e28529a076a1338a2d3d" title="This function checks if the entire string contains ascii characters. ">strisascii_s()</a>, <a class="el" href="../../da/db8/strisdigit__s_8c.html#af6d2b2392726a66476a6479842142679" title="This function checks that the entire string contains digits. ">strisdigit_s()</a>, <a class="el" href="../../d1/d33/strishex__s_8c.html#a4ea325a1dbaee49509ed759dc12b41e1" title="This function checks that the entire string contains hex characters. ">strishex_s()</a>, <a class="el" href="../../d7/d8d/strismixedcase__s_8c.html#a48432b5227c0482f5a4f9007b9a91e62" title="This function checks that the entire string is mixed case. ">strismixedcase_s()</a>, <a class="el" href="../../dd/d9f/strisuppercase__s_8c.html#a75fd0f3c25590af5a836afe1fca4db16" title="This function checks if entire string is uppercase The scanning stops at the first null or after dmax...">strisuppercase_s()</a> </dd></dl>

</div>
</div>
<a id="a325b07c57952b98e580d777dc52175a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325b07c57952b98e580d777dc52175a2">&#9670;&nbsp;</a></span>strismixedcase_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strismixedcase_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks that the entire string is mixed case. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when string is mixed case </dd>
<dd>
false when string is not mixed case or error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dc9/strisalphanumeric__s_8c.html#a67d621438c8b718945ef21e65351eef6" title="This function checks if the entire string contains alphanumerics. ">strisalphanumeric_s()</a>, <a class="el" href="../../d8/dd0/strisascii__s_8c.html#a7ed626fac212e28529a076a1338a2d3d" title="This function checks if the entire string contains ascii characters. ">strisascii_s()</a>, <a class="el" href="../../da/db8/strisdigit__s_8c.html#af6d2b2392726a66476a6479842142679" title="This function checks that the entire string contains digits. ">strisdigit_s()</a>, <a class="el" href="../../d1/d33/strishex__s_8c.html#a4ea325a1dbaee49509ed759dc12b41e1" title="This function checks that the entire string contains hex characters. ">strishex_s()</a>, <a class="el" href="../../de/d5b/strislowercase__s_8c.html#a821e868be7e53a143217aac37f29b971" title="This function checks if entire string is lowercase. ">strislowercase_s()</a>, <a class="el" href="../../dd/d9f/strisuppercase__s_8c.html#a75fd0f3c25590af5a836afe1fca4db16" title="This function checks if entire string is uppercase The scanning stops at the first null or after dmax...">strisuppercase_s()</a> </dd></dl>

</div>
</div>
<a id="a6b06e5161c76aeb15b1f7692a2d5e44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b06e5161c76aeb15b1f7692a2d5e44a">&#9670;&nbsp;</a></span>strispassword_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strispassword_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function validates the make-up of a password string. </p>
<p>-Password must have mininmum SAFE_STR_PASSWORD_MIN_LENGTH characters <br />
 -Password can have maximum SAFE_STR_PASSWORD_MAX_LENGTH characters <br />
 -Password must have at least SAFE_STR_MIN_LOWERCASE lower case characters <br />
 -Password must have at least SAFE_STR_MIN_UPPERCASE upper case characters <br />
 -Password must have at least SAFE_STR_MIN_NUMBERS numbers <br />
 -Password must have at least SAFE_STR_MIN_SPECIALS special characters</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of password string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax &gt; SAFE_STR_PASSWORD_MIN_LENGTH </dd>
<dd>
dmax &lt; SAFE_STR_PASSWORD_MAX_LENGTH </dd>
<dd>
dest shall not be unterminated</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when string has valid password makeup </dd>
<dd>
false when string does not meet requirements or an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d88/strzero__s_8c.html#a8f450ba4c1ab7a4a7471b9be7007ae03" title="Nulls maximal dmax characters of dest. ">strzero_s()</a> </dd></dl>

</div>
</div>
<a id="af7ce12baf626ecaad13652bcac2c21f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce12baf626ecaad13652bcac2c21f7">&#9670;&nbsp;</a></span>strisuppercase_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> bool strisuppercase_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if entire string is uppercase The scanning stops at the first null or after dmax characters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when string is uppercase </dd>
<dd>
false when string is not uppercase or an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dc9/strisalphanumeric__s_8c.html#a67d621438c8b718945ef21e65351eef6" title="This function checks if the entire string contains alphanumerics. ">strisalphanumeric_s()</a>, <a class="el" href="../../d8/dd0/strisascii__s_8c.html#a7ed626fac212e28529a076a1338a2d3d" title="This function checks if the entire string contains ascii characters. ">strisascii_s()</a>, <a class="el" href="../../da/db8/strisdigit__s_8c.html#af6d2b2392726a66476a6479842142679" title="This function checks that the entire string contains digits. ">strisdigit_s()</a>, <a class="el" href="../../d1/d33/strishex__s_8c.html#a4ea325a1dbaee49509ed759dc12b41e1" title="This function checks that the entire string contains hex characters. ">strishex_s()</a>, <a class="el" href="../../de/d5b/strislowercase__s_8c.html#a821e868be7e53a143217aac37f29b971" title="This function checks if entire string is lowercase. ">strislowercase_s()</a>, <a class="el" href="../../d7/d8d/strismixedcase__s_8c.html#a48432b5227c0482f5a4f9007b9a91e62" title="This function checks that the entire string is mixed case. ">strismixedcase_s()</a>, </dd></dl>

</div>
</div>
<a id="a869f5038d30bff33f82415022d4da617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869f5038d30bff33f82415022d4da617">&#9670;&nbsp;</a></span>strlastchar_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strlastchar_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the last occurrence of character c in dest. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to locate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">last</td><td>returned pointer to first occurrence of c</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
last shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to last occurence of c, NULL if not found </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when pointer to last occurrence is returned </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dst/first is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d01/strfirstchar__s_8c.html#a72b0c60fced8d289a6adcb11b0516217" title="This function returns a pointer to the first occurrence of character c in dest. ">strfirstchar_s()</a>, <a class="el" href="../../de/d3e/strfirstdiff__s_8c.html#a8de98455a2e24d2da4911cbd19d56d8e" title="Returns the index of the first character that is different between dest and src. ">strfirstdiff_s()</a>, <a class="el" href="../../d5/d5e/strfirstsame__s_8c.html#a489bc1f6ad88c01073f128cad2a45d1f" title="Returns the index of the first character that is the same between dest and src. ">strfirstsame_s()</a>, <a class="el" href="../../d9/dfe/strlastdiff__s_8c.html#a11e1abfe1dae56e7a198c19e6c1c6dc5" title="Returns the index of the last character that is different between dest and src. ">strlastdiff_s()</a>, <a class="el" href="../../da/db5/strlastsame__s_8c.html#afc7a385ce2e44ee19042af09fc0ce36f" title="Returns the index of the last character that is the same between dest and src. ">strlastsame_s()</a> </dd></dl>

</div>
</div>
<a id="aa8dfb6c764602668ed1eaae9d6df5410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dfb6c764602668ed1eaae9d6df5410">&#9670;&nbsp;</a></span>strlastdiff_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strlastdiff_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the last character that is different between dest and src. </p>
<p>Index is valid only for EOK. The scanning stops at the first null in dest or src, or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>pointer to returned index to last difference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>index to last difference, when the return code is OK </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when index to last diff is returned </td></tr>
    <tr><td class="paramname">ESNODIFF</td><td>when no difference </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/index is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d01/strfirstchar__s_8c.html#a72b0c60fced8d289a6adcb11b0516217" title="This function returns a pointer to the first occurrence of character c in dest. ">strfirstchar_s()</a>, <a class="el" href="../../de/d3e/strfirstdiff__s_8c.html#a8de98455a2e24d2da4911cbd19d56d8e" title="Returns the index of the first character that is different between dest and src. ">strfirstdiff_s()</a>, <a class="el" href="../../d5/d5e/strfirstsame__s_8c.html#a489bc1f6ad88c01073f128cad2a45d1f" title="Returns the index of the first character that is the same between dest and src. ">strfirstsame_s()</a>, <a class="el" href="../../d7/d19/strlastchar__s_8c.html#a467f98690a5729be9d4ea0c620147cf9" title="Returns a pointer to the last occurrence of character c in dest. ">strlastchar_s()</a>, <a class="el" href="../../da/db5/strlastsame__s_8c.html#afc7a385ce2e44ee19042af09fc0ce36f" title="Returns the index of the last character that is the same between dest and src. ">strlastsame_s()</a> </dd></dl>

</div>
</div>
<a id="a816e0c2157d99131ba398b76445e9de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816e0c2157d99131ba398b76445e9de5">&#9670;&nbsp;</a></span>strljustify_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strljustify_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes beginning whitespace from the string pointed to by dest by shifting the text left over writting the beginning whitespace, left justifying the text. </p>
<p>The left justified text is null terminated. The text is shifted so the original pointer can continue to be used.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string to left justify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR </dd>
<dd>
dest shall be null terminated</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESUNTERM</td><td>when dest was not null terminated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/df4/strremovews__s_8c.html#ac6a35b0ec6c61af72e02f74caf3d6d61" title="Removes beginning and trailing whitespace from the string pointed to by dest by shifting the text lef...">strremovews_s()</a>, </dd></dl>

</div>
</div>
<a id="a17a2702b0c90ce02421115dfe9884f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a2702b0c90ce02421115dfe9884f8e">&#9670;&nbsp;</a></span>strnterminate_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> <a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> strnterminate_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strnterminate_s function will terminate the string if a null is not encountered before dmax characters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a terminated string. If a null is not encountered prior to dmax characters, the dmax character is set to null terminating the string. The string length is also returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d06/strnlen__s_8c.html#a72f988b24df8122611e4d6132b3f93ab" title="The strnlen_s function computes the length of the string pointed to by dest. ">strnlen_s()</a> </dd></dl>

</div>
</div>
<a id="a60e356eec3ebcf6ed95ad0758f125f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e356eec3ebcf6ed95ad0758f125f10">&#9670;&nbsp;</a></span>strpbrk_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strpbrk_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer, first, to the first ocurrence of any character in src which is contained in dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the string </td></tr>
    <tr><td class="paramname">slen</td><td>restricted length of string src </td></tr>
    <tr><td class="paramname">first</td><td>returned pointer to first occurence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
Neither dmax nor slen shall not be 0. </dd>
<dd>
Neither dmax nor slen shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first ocurrence of any character contained in src </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/first is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d01/strfirstchar__s_8c.html#a72b0c60fced8d289a6adcb11b0516217" title="This function returns a pointer to the first occurrence of character c in dest. ">strfirstchar_s()</a>, <a class="el" href="../../d7/d19/strlastchar__s_8c.html#a467f98690a5729be9d4ea0c620147cf9" title="Returns a pointer to the last occurrence of character c in dest. ">strlastchar_s()</a>, <a class="el" href="../../de/d3e/strfirstdiff__s_8c.html#a8de98455a2e24d2da4911cbd19d56d8e" title="Returns the index of the first character that is different between dest and src. ">strfirstdiff_s()</a>, <a class="el" href="../../d5/d5e/strfirstsame__s_8c.html#a489bc1f6ad88c01073f128cad2a45d1f" title="Returns the index of the first character that is the same between dest and src. ">strfirstsame_s()</a>, <a class="el" href="../../d9/dfe/strlastdiff__s_8c.html#a11e1abfe1dae56e7a198c19e6c1c6dc5" title="Returns the index of the last character that is different between dest and src. ">strlastdiff_s()</a>, <a class="el" href="../../da/db5/strlastsame__s_8c.html#afc7a385ce2e44ee19042af09fc0ce36f" title="Returns the index of the last character that is the same between dest and src. ">strlastsame_s()</a> </dd></dl>

</div>
</div>
<a id="a7bbd16eab61a5c4eb818d48da3a3bcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbd16eab61a5c4eb818d48da3a3bcc3">&#9670;&nbsp;</a></span>strfirstsame_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strfirstsame_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the first character that is the same between dest and src. </p>
<p>The scanning stops at the fisrt null in dest or src, or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>pointer to returned index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>index to first same char, when the return code is OK </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when index to first same char is returned </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dst/src/index is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d01/strfirstchar__s_8c.html#a72b0c60fced8d289a6adcb11b0516217" title="This function returns a pointer to the first occurrence of character c in dest. ">strfirstchar_s()</a>, <a class="el" href="../../de/d3e/strfirstdiff__s_8c.html#a8de98455a2e24d2da4911cbd19d56d8e" title="Returns the index of the first character that is different between dest and src. ">strfirstdiff_s()</a>, <a class="el" href="../../d7/d19/strlastchar__s_8c.html#a467f98690a5729be9d4ea0c620147cf9" title="Returns a pointer to the last occurrence of character c in dest. ">strlastchar_s()</a>, <a class="el" href="../../d9/dfe/strlastdiff__s_8c.html#a11e1abfe1dae56e7a198c19e6c1c6dc5" title="Returns the index of the last character that is different between dest and src. ">strlastdiff_s()</a>, <a class="el" href="../../da/db5/strlastsame__s_8c.html#afc7a385ce2e44ee19042af09fc0ce36f" title="Returns the index of the last character that is the same between dest and src. ">strlastsame_s()</a> </dd></dl>

</div>
</div>
<a id="a6ce98e6dace379678bc5e1204cd79c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce98e6dace379678bc5e1204cd79c32">&#9670;&nbsp;</a></span>strlastsame_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strlastsame_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the last character that is the same between dest and src. </p>
<p>The scanning stops at the first nul in dest or src, or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>pointer to returned index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>index to last same char, when the return code is OK </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when index to last same char is returned </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dst/src/index is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d01/strfirstchar__s_8c.html#a72b0c60fced8d289a6adcb11b0516217" title="This function returns a pointer to the first occurrence of character c in dest. ">strfirstchar_s()</a>, <a class="el" href="../../de/d3e/strfirstdiff__s_8c.html#a8de98455a2e24d2da4911cbd19d56d8e" title="Returns the index of the first character that is different between dest and src. ">strfirstdiff_s()</a>, <a class="el" href="../../d5/d5e/strfirstsame__s_8c.html#a489bc1f6ad88c01073f128cad2a45d1f" title="Returns the index of the first character that is the same between dest and src. ">strfirstsame_s()</a>, <a class="el" href="../../d7/d19/strlastchar__s_8c.html#a467f98690a5729be9d4ea0c620147cf9" title="Returns a pointer to the last occurrence of character c in dest. ">strlastchar_s()</a>, <a class="el" href="../../d9/dfe/strlastdiff__s_8c.html#a11e1abfe1dae56e7a198c19e6c1c6dc5" title="Returns the index of the last character that is different between dest and src. ">strlastdiff_s()</a> </dd></dl>

</div>
</div>
<a id="a3252f7ee23313f430a69bf2ff875a36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3252f7ee23313f430a69bf2ff875a36b">&#9670;&nbsp;</a></span>strprefix_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strprefix_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the prefix pointed to by src is at the beginning of string pointed to by dest. </p>
<p>The prefix must be a complete match in dest. Useful for command or user input parsing. The scanning stops at the first null in dest or src, or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the prefix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
Neither dmax nor slen shall not be 0. </dd>
<dd>
Neither dmax nor slen shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, substring found. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/substring is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when prefix not found in dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/df1/strspn__s_8c.html#a88170b384d5975577bb20c898bdc6c5d" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strspn_s()</a>, <a class="el" href="../../dd/d73/strcspn__s_8c.html#ac8ef1278758db78e33f613b09ac63299" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strcspn_s()</a>, <a class="el" href="../../de/dd3/strpbrk__s_8c.html#ab7cdbee62fb36f9883dbc4eb7a9629a0" title="Returns a pointer, first, to the first ocurrence of any character in src which is contained in dest...">strpbrk_s()</a>, <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a> </dd></dl>

</div>
</div>
<a id="a4ddfa37f06f78adb9714262c3c9f6841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddfa37f06f78adb9714262c3c9f6841">&#9670;&nbsp;</a></span>strremovews_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strremovews_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes beginning and trailing whitespace from the string pointed to by dest by shifting the text left over writting the beginning whitespace (space or tab). </p>
<p>The shifted-trimmed text is null terminated. The text is shifted so the original pointer can continue to be used. This is useful when the memory was malloc'ed and will need to be freed.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string to left justify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR </dd>
<dd>
dest shall be null terminated</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESUNTERM</td><td>when dest was not null terminated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d10/strljustify__s_8c.html#a51047cb73d499e17279ad93a38614922" title="Removes beginning whitespace from the string pointed to by dest by shifting the text left over writti...">strljustify_s()</a>, </dd></dl>

</div>
</div>
<a id="ac4f1003adfb3b52164ce332b72d51678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f1003adfb3b52164ce332b72d51678">&#9670;&nbsp;</a></span>strspn_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strspn_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the prefix length of the string pointed to by dest which consists entirely of characters that are included from the string pointed to by src. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to determine the prefix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to exclusion string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>restricted maximum length of string src </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>pointer to a count variable that will be updated with the dest substring length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
count shall not be a null pointer. </dd>
<dd>
Neither dmax nor slen shall not be 0. </dd>
<dd>
Neither dmax nor slen shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, substring found. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/substring is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d73/strcspn__s_8c.html#ac8ef1278758db78e33f613b09ac63299" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strcspn_s()</a>, <a class="el" href="../../de/dd3/strpbrk__s_8c.html#ab7cdbee62fb36f9883dbc4eb7a9629a0" title="Returns a pointer, first, to the first ocurrence of any character in src which is contained in dest...">strpbrk_s()</a>, <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a>, <a class="el" href="../../d2/d9c/strprefix__s_8c.html#a6348bed5e142178bf8fb623adc82c48d" title="Determines if the prefix pointed to by src is at the beginning of string pointed to by dest...">strprefix_s()</a> </dd></dl>

</div>
</div>
<a id="a2abe995a4bd9200e4b2ae14e98bea44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abe995a4bd9200e4b2ae14e98bea44c">&#9670;&nbsp;</a></span>strstr_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strstr_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a> function locates the first occurrence of the substring pointed to by src which would be located in the string pointed to by dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO<ul>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to be searched for the substring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the sub string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>the maximum number of characters to use from src </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">substring</td><td>the returned substring pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
Neither dmax nor slen shall not be 0. </dd>
<dd>
Neither dmax nor slen shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, substring found. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/substring is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when substring not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/d9c/strprefix__s_8c.html#a6348bed5e142178bf8fb623adc82c48d" title="Determines if the prefix pointed to by src is at the beginning of string pointed to by dest...">strprefix_s()</a>, <a class="el" href="../../d9/df1/strspn__s_8c.html#a88170b384d5975577bb20c898bdc6c5d" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strspn_s()</a>, <a class="el" href="../../dd/d73/strcspn__s_8c.html#ac8ef1278758db78e33f613b09ac63299" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strcspn_s()</a>, <a class="el" href="../../de/dd3/strpbrk__s_8c.html#ab7cdbee62fb36f9883dbc4eb7a9629a0" title="Returns a pointer, first, to the first ocurrence of any character in src which is contained in dest...">strpbrk_s()</a> </dd></dl>

</div>
</div>
<a id="a6ae4847201ef47b5f0b869881d26ed2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae4847201ef47b5f0b869881d26ed2b">&#9670;&nbsp;</a></span>strchr_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strchr_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated byte string pointed to by dest (each character interpreted as unsigned char). </p>
<p>The terminating null character is considered to be a part of the string and can be found when searching for '\0'.</p>
<dl class="section remark"><dt>Remarks</dt><dd>IMPLEMENTED IN</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to char* in dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor result shall be a null pointer. </dd>
<dd>
dmax shall not be 0. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
ch shall not be greater than 255</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successfully character found. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/result is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when ch &gt; 255 </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when ch not found in dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/d0e/memchr__s_8c.html#abad54ce7977ff35586d1bbf954802a2d" title="Finds the first occurrence of ch (after conversion to unsigned char as if by (unsigned char)ch) in th...">memchr_s()</a>, <a class="el" href="../../d9/df1/strspn__s_8c.html#a88170b384d5975577bb20c898bdc6c5d" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strspn_s()</a>, <a class="el" href="../../dd/d73/strcspn__s_8c.html#ac8ef1278758db78e33f613b09ac63299" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strcspn_s()</a>, <a class="el" href="../../de/dd3/strpbrk__s_8c.html#ab7cdbee62fb36f9883dbc4eb7a9629a0" title="Returns a pointer, first, to the first ocurrence of any character in src which is contained in dest...">strpbrk_s()</a>, <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a> </dd></dl>

</div>
</div>
<a id="a3a5b47f61548fcec9fc7bc95877c8554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5b47f61548fcec9fc7bc95877c8554">&#9670;&nbsp;</a></span>strrchr_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strrchr_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated byte string pointed to by dest (each character interpreted as unsigned char). </p>
<p>The terminating null character is considered to be a part of the string and can be found when searching for '\0'. Unlike strrchr() it honors dmax as maximal string length.</p>
<dl class="section remark"><dt>Remarks</dt><dd>IMPLEMENTED IN</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to search for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to char* in dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor result shall be a null pointer. </dd>
<dd>
dmax shall not be 0. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
ch shall not be greater than 255</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successfully character found. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/result is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 or strnlen_s = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when ch &gt; 255 </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when ch not found in dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/def/memrchr__s_8c.html#aa639e15acb0ca248ca25608105abcd99" title="Finds the last occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated b...">memrchr_s()</a>, <a class="el" href="../../d3/dfa/strchr__s_8c.html#a95f8084c2c56e2046db592e3c87d15a1" title="Finds the first occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated ...">strchr_s()</a>, <a class="el" href="../../d7/d0e/memchr__s_8c.html#abad54ce7977ff35586d1bbf954802a2d" title="Finds the first occurrence of ch (after conversion to unsigned char as if by (unsigned char)ch) in th...">memchr_s()</a>, <a class="el" href="../../d9/df1/strspn__s_8c.html#a88170b384d5975577bb20c898bdc6c5d" title="This function computes the prefix length of the string pointed to by dest which consists entirely of ...">strspn_s()</a>, <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a> </dd></dl>

</div>
</div>
<a id="a39d393f60f6de53c22c2285ec379a046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d393f60f6de53c22c2285ec379a046">&#9670;&nbsp;</a></span>strtolowercase_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strtolowercase_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the string converting uppercase characters to lowercase, leaving all other characters unchanged. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d6f/strtouppercase__s_8c.html#a16c5f6402d37729b8598969dc25cb8d2" title="Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged...">strtouppercase_s()</a> </dd></dl>

</div>
</div>
<a id="a38d442591898fb246a2bd5aa590a6921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d442591898fb246a2bd5aa590a6921">&#9670;&nbsp;</a></span>strtouppercase_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strtouppercase_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged. </p>
<p>The scanning stops at the first null or after dmax characters.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<p>ALSO SEE <a class="el" href="../../d3/d0c/strtolowercase__s_8c.html#ac2888d3274e303d743f0edb158436dfa" title="Scans the string converting uppercase characters to lowercase, leaving all other characters unchanged...">strtolowercase_s()</a> </p>

</div>
</div>
<a id="aa4cdabeafa0bdc6d3af9a37d70e24103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cdabeafa0bdc6d3af9a37d70e24103">&#9670;&nbsp;</a></span>strzero_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strzero_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nulls maximal dmax characters of dest. </p>
<p>This function can be used to clear strings that contained sensitive data, until the terminating NULL character. With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to string that will be nulled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/d08/strispassword__s_8c.html#acf0187b8c0aeb42c265ea1a79e5ccab9" title="This function validates the make-up of a password string. ">strispassword_s()</a> </dd></dl>

</div>
</div>
<a id="a4b22cfd1f08f4bbdbc805ae997f8cb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b22cfd1f08f4bbdbc805ae997f8cb49">&#9670;&nbsp;</a></span>strcoll_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strcoll_s </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two null-terminated byte strings according to the current locale as defined by the <code>LC_COLLATE</code> category. </p>
<p>Collation order is the dictionary order: the position of the letter in the national alphabet (its equivalence class) has higher priority than its case or variant. Within an equivalence class, lowercase characters collate before their uppercase equivalents and locale-specific order may apply to the characters with diacritics. In some locales, groups of characters compare as single collation units. For example, "ch" in Czech follows "h" and precedes "i", and "dzs" in Hungarian follows "dz" and precedes "g".</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string to be compared to dest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indicator</td><td>pointer to result indicator, greater than 0, equal to 0 or less than 0, if the string pointed to by dest is greater than, equal to or less than the string pointed to by src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax shall not be 0 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>indicator (when the return code is OK) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>when dest greater than src </td></tr>
    <tr><td class="paramname">0</td><td>when strings the same </td></tr>
    <tr><td class="paramname">&lt;0</td><td>when dest less than src </td></tr>
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/indicator is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/dd8/wcscoll__s_8c.html#a14da8ac69ed63c0dd6cb517fc73d9095" title="Compares two null-terminated wide strings according to the current locale as defined by the LC_COLLAT...">wcscoll_s()</a>, <a class="el" href="../../d1/d7b/strcmp__s_8c.html#a1af73c8a0a8e2f7abc5a1a78f154fa8e" title="Compares string src to string dest. ">strcmp_s()</a>, <a class="el" href="../../d4/d7c/strcasecmp__s_8c.html#ae11b6060ef450062df8082045083bec1" title="Case insensitive string comparison by converting to uppercase prior to the compare. ">strcasecmp_s()</a> </dd></dl>

</div>
</div>
<a id="aa017ab253b65c6fda098dc6ae06afe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa017ab253b65c6fda098dc6ae06afe20">&#9670;&nbsp;</a></span>strset_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strset_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets maximal dmax characters of dest to a character value, but not the final NULL character. </p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO<ul>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
<li>Implemented in the Windows secure API as _strset_s()</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>string that will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>character value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer, and shall be null-terminated. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
value shall not be greater than 255</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR or value &gt; 255</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d88/strzero__s_8c.html#a8f450ba4c1ab7a4a7471b9be7007ae03" title="Nulls maximal dmax characters of dest. ">strzero_s()</a>, <a class="el" href="../../da/d45/strnset__s_8c.html#ac8ee0f7bddb6dd004118488a4fef6b85" title="Sets maximal n characters of dest to a character value, but not the final NULL character. ">strnset_s()</a>, <a class="el" href="../../d2/d08/strispassword__s_8c.html#acf0187b8c0aeb42c265ea1a79e5ccab9" title="This function validates the make-up of a password string. ">strispassword_s()</a> </dd></dl>

</div>
</div>
<a id="adde4cdc3194a0f9facdf2956ca88cdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde4cdc3194a0f9facdf2956ca88cdca">&#9670;&nbsp;</a></span>strnset_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t strnset_s </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets maximal n characters of dest to a character value, but not the final NULL character. </p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO<ul>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
<li>Implemented in the Windows secure API as _strnset_s()</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>string that will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>character value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of characters to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer, and shall be null-terminated. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_STR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
n shall not be greater than dmax </dd>
<dd>
value shall not be greater than 255</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR or value &gt; 255 </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when n &gt; dmax</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d88/strzero__s_8c.html#a8f450ba4c1ab7a4a7471b9be7007ae03" title="Nulls maximal dmax characters of dest. ">strzero_s()</a>, <a class="el" href="../../d3/d98/strset__s_8c.html#a697c3cdacea11c16986a91cec67b52b5" title="Sets maximal dmax characters of dest to a character value, but not the final NULL character...">strset_s()</a>, <a class="el" href="../../dc/d0c/wcsnset__s_8c.html#a2e80982de4fc741d488f6086e0880ce4" title="Sets maximal n wide characters of dest to a wide character value, but not the final NULL character...">wcsnset_s()</a>, <a class="el" href="../../d2/d08/strispassword__s_8c.html#acf0187b8c0aeb42c265ea1a79e5ccab9" title="This function validates the make-up of a password string. ">strispassword_s()</a> </dd></dl>

</div>
</div>
<a id="aba404d1c29fcf07405871166222e61f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba404d1c29fcf07405871166222e61f4">&#9670;&nbsp;</a></span>mbstowcs_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t mbstowcs_s </td>
          <td>(</td>
          <td class="paramtype">size_t *restrict&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addb3b0ad918710ecfe6fe25e58cb7410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb3b0ad918710ecfe6fe25e58cb7410">&#9670;&nbsp;</a></span>mbsrtowcs_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t mbsrtowcs_s </td>
          <td>(</td>
          <td class="paramtype">size_t *restrict&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbstate_t *restrict&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does not permit the <code>ps</code> parameter (the pointer to the conversion state) to be a null pointer. </p>
<p>The restartable <code>mbsrtowcs_s</code> function converts a null-terminated multibyte character sequence from the current LC_CTYPE locale to wchar, which begins in the conversion state described by <code>*ps</code>, from the array whose first element is pointed to by <code>*src</code> to its wide character representation. If dest is not null, converted characters are stored in the successive elements of the <code>wchar_t</code> array pointed to by <code>dest</code>. No more than <code>len</code> wide characters are written to the destination array. Each multibyte character is converted as if by a call to <code>mbrtowc</code>. <code>mbsrtowcs_s</code> clobbers the destination array from the terminating null and until <code>dmax</code>. In extension to <code>mbstowc_s</code> you can re-use the state via <code>ps</code>. With SAFECLIB_STR_NULL_SLACK defined the rest is cleared with 0.</p>
<p>The conversion stops if:</p>
<ul>
<li>The multibyte null character was converted and stored. <code>*src</code> is set to <code>NULL</code> and <code>*ps</code> represents the initial shift state.</li>
<li>An invalid multibyte character (according to the current C locale) was encountered. <code>*src</code> is set to point at the beginning of the first unconverted multibyte character.</li>
<li>the next wide character to be stored would exceed <code>len</code>. <code>*src</code> is set to point at the beginning of the first unconverted multibyte character. This condition is not checked if <code>dest==NULL</code>.</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.3.2.1 The mbsrtowcs_s function (p: 648-649) <a href="http://en.cppreference.com/w/c/string/byte/mbsrtowcs">http://en.cppreference.com/w/c/string/byte/mbsrtowcs</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">retval</td><td>pointer to a <code>size_t</code> object where the result will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide character array where the results will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the string that will be copied to <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>maximal number of wide characters to be copied to <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>pointer to the conversion state object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>retval, ps, src, or *src shall not be a null pointer. </dd>
<dd>
dmax and len shall not be greater than <code>RSIZE_MAX_WSTR</code> (unless dest is null). </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall be greater than <code>wcsnlen_s(src, dmax)</code>. </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then <code>mbsrtowcs_s</code> nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful conversion. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when retval, ps, src or *src are a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when src and dest overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when there is no null character in the first dmax multibyte characters in the *src array and len is greater than dmax (unless dest is null)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>mbstowc_s() </dd></dl>

</div>
</div>
<a id="a0999a2ddd3afe9c4538d029dce4fb90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0999a2ddd3afe9c4538d029dce4fb90b">&#9670;&nbsp;</a></span>wcsrtombs_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsrtombs_s </td>
          <td>(</td>
          <td class="paramtype">size_t *restrict&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t **restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbstate_t *restrict&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does not permit the <code>ps</code> parameter (the pointer to the conversion state) to be a null pointer. </p>
<p>The restartable <code>wcsrtombs_s</code> function converts a sequence of wide characters from the array whose first element is pointed to by <code>*src</code> to to its narrow multibyte representation from the current LC_CTYPE locale that begins in the conversion state described by <code>*ps</code>. If <code>dest</code> is not null, converted characters are stored in the successive elements of <code>dest</code>. No more than <code>len</code> bytes written to the destination array. Each wide character is converted as if by a call to <code>wcrtomb</code>. <code>wcsrtombs_s</code> clobbers the destination array from the terminating null and until <code>dmax</code>. In extension to <code>wcstombs_s</code> you can re-use the state via <code>ps</code>.</p>
<p>The conversion stops if:</p>
<ul>
<li>The wide null character <code>L'\0'</code> was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by <code>'\0'</code>, <code>*src</code> is set to <code>NULL</code> and <code>*ps</code> represents the initial shift state.</li>
<li>A <code>wchar_t</code> was found that does not correspond to a valid character in the current LC_CTYPE locale. <code>*src</code> is set to point at the first unconverted wide character.</li>
<li>the next multibyte character to be stored would exceed <code>len</code>. <code>*src</code> is set to point at the beginning of the first unconverted wide character. This condition is not checked if <code>dst==NULL</code>.</li>
</ul>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled. Also in the error cases for src = NULL, *src = NULL, ESNOSPC and EILSEQ.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.3.2.2 The wcsrtombs_s function (p: 649-650) <a href="http://en.cppreference.com/w/c/string/wide/wcsrtombs">http://en.cppreference.com/w/c/string/wide/wcsrtombs</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">retval</td><td>pointer to a <code>size_t</code> object where the result will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to character array where the result will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the wide string that will be copied to <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes available in <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>pointer to the conversion state object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>retval, ps, src, or *src shall not be a null pointer. </dd>
<dd>
dmax and len shall not be greater than <code>RSIZE_MAX_STR</code> (unless dest is null). </dd>
<dd>
dmax shall not equal zero (unless dest is null). </dd>
<dd>
dmax shall be greater than <code>len</code>. </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if <code>dest</code> is not a null pointer and <code>dmax</code> is greater than zero and not greater than RSIZE_MAX_STR, then <code>wcsrtombs_s</code> nulls <code>dest</code>. Then the number of bytes excluding terminating zero that were, or would be written to <code>dest</code>, is stored in <code>*retval</code>. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful conversion. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when retval, ps, src or *src are a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when src and dest overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when there is no null character in the first dmax multibyte characters in the *src array and len is greater than dmax (unless dest is null) </td></tr>
    <tr><td class="paramname">EILSEQ</td><td>if returned by wctomb()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d37/wcrtomb__s_8c.html#a45b0fbb8f40fb56bec9d9240d83907d9" title="Does not permit the ps parameter (the pointer to the conversion state) to be a null pointer...">wcrtomb_s()</a>, <a class="el" href="../../d5/db9/wcstombs__s_8c.html#a622fcfc636877244ea3f835b43bbde37" title="The wcstombs_s function converts a sequence of wide characters from the array whose first element is ...">wcstombs_s()</a> </dd></dl>

</div>
</div>
<a id="ad803161f1adba44ff57a7c751549221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad803161f1adba44ff57a7c751549221c">&#9670;&nbsp;</a></span>wcstombs_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcstombs_s </td>
          <td>(</td>
          <td class="paramtype">size_t *restrict&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>wcstombs_s</code> function converts a sequence of wide characters from the array whose first element is pointed to by <code>src</code> to to its narrow multibyte representation from the current LC_CTYPE locale. </p>
<p>If <code>dest</code> is not null, converted characters are stored in the successive elements of <code>dest</code>. No more than <code>len</code> bytes are written to the destination array. Each wide character is converted as if by a call to <code>wcrtomb</code>. <code>wcstombs_s</code> clobbers the destination array from the terminating null and until <code>dmax</code>.</p>
<p>The conversion stops if:</p>
<ul>
<li>The wide null character <code>L'\0'</code> was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by <code>'\0'</code>.</li>
<li>A <code>wchar_t</code> was found that does not correspond to a valid character in the current LC_CTYPE locale.</li>
<li>the next multibyte character to be stored would exceed <code>len</code>. This condition is not checked if <code>dst==NULL</code>.</li>
</ul>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled. Also in the error cases for src = NULL, ESNOSPC and EILSEQ.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.6.5.2 The wcstombs_s function (p: 612-613) <a href="http://en.cppreference.com/w/c/string/byte/wcstombs">http://en.cppreference.com/w/c/string/byte/wcstombs</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">retval</td><td>the number of characters converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>buffer for the resulting converted multibyte character string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>The size in bytes of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string that will be converted to <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to be stored in <code>dest</code>, not including the terminating null character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>retval</code> and <code>src</code> shall not be a null pointer. </dd>
<dd>
dmax and len shall not be greater than <code>RSIZE_MAX_STR</code> (unless <code>dest</code> is null). </dd>
<dd>
<code>dmax</code> shall not equal zero (unless <code>dest</code> is null). </dd>
<dd>
<code>dmax</code> shall be greater than <code>len</code>. </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if <code>dest</code> is not a null pointer and <code>dmax</code> is greater than zero and not greater than RSIZE_MAX_STR, then <code>wcstombs_s</code> nulls <code>dest</code>. Then the number of bytes excluding terminating zero that were, or would be written to <code>dest</code>, is stored in <code>*retval</code>. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful conversion. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when retval or src are a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when src and dest overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when there is no null character in the first dmax multibyte characters in the src array and len is greater than dmax (unless dest is null) </td></tr>
    <tr><td class="paramname">EILSEQ</td><td>if returned by wcstombs()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>mbstowc_s() </dd></dl>

</div>
</div>
<a id="a7294e6f32936b6d2905282e710d97da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7294e6f32936b6d2905282e710d97da6">&#9670;&nbsp;</a></span>wcrtomb_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcrtomb_s </td>
          <td>(</td>
          <td class="paramtype">size_t *restrict&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>wc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbstate_t *restrict&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does not permit the <code>ps</code> parameter (the pointer to the conversion state) to be a null pointer. </p>
<p>The restartable <code>wcrtomb_s</code> function converts a single wide character to its narrow multibyte representation from the current LC_CTYPE locale that begins in the conversion state described by <code>*ps</code>. If <code>dest</code> is not null, the converted multibyte characters are stored in <code>dest</code>. Max. <code>MB_CUR_MAX</code> will be written to <code>dest</code>.</p>
<p>If <code>dest</code> is a null pointer, the call is equivalent to <code>wcrtomb_s(&amp;retval, buf, sizeof buf, L'\0', ps)</code> with internal variables <code>retval</code> and <code>buf</code> (whose size is greater than <code>MB_CUR_MAX</code>).</p>
<p>If wc is the null wide character L'\0', a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter *ps is updated to represent the initial shift state.</p>
<p>If the environment macro <b>STDC_ISO_10646</b> is defined, the values of type wchar_t are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p>
<p>If the environment macro <b>STDC_MB_MIGHT_NEQ_WC</b> is defined, then for members of the basic character set multibyte-character encoding might not equal wide-character encoding (non-ASCII-based systems, such as EBCDIC-based systems, may use Unicode for their wide character encoding and still be conforming). ASCII-based systems with <b>STDC_ISO_10646</b> defined leave <b>STDC_MB_MIGHT_NEQ_WC</b> undefined.</p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.3.1.1 The wcrtomb_s function (p: 647-648) <a href="http://en.cppreference.com/w/c/string/wide/wcrtomb">http://en.cppreference.com/w/c/string/wide/wcrtomb</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">retval</td><td>pointer to a <code>size_t</code> object where the result will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to bytes where the result will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>the wide character to convert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>pointer to the conversion state object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>retval and ps shall not be a null pointer. </dd>
<dd>
dmax shall not be greater than <code>RSIZE_MAX_STR</code> (unless dest is null). </dd>
<dd>
dmax shall not equal zero (unless dest is null). </dd>
<dd>
dmax must be zero if dest is null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns zero on success and non-zero on failure, in which case, <code>dest</code>[0] is set to '\0' (unless dest is null or dmax is zero or greater than RSIZE_MAX_STR) and <code>*retval</code> is set to (size_t)-1 (unless retval is null).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful conversion. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when retval or ps are a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax is smaller than the number of required bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/dd4/wctomb__s_8c.html#af5811dc63ddf86777b7674a155d63a76" title="The wctomb_s function converts a single wide character to its narrow multibyte representation from th...">wctomb_s()</a> </dd></dl>

</div>
</div>
<a id="a88e1df63ddc71b3307d2964bc88af81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e1df63ddc71b3307d2964bc88af81c">&#9670;&nbsp;</a></span>wctomb_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wctomb_s </td>
          <td>(</td>
          <td class="paramtype">int *restrict&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>wc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>wctomb_s</code> function converts a single wide character to its narrow multibyte representation from the current LC_CTYPE locale. </p>
<p>If <code>dest</code> is not null, the converted multibyte characters are stored in <code>dest</code>. Max. <code>MB_CUR_MAX</code> will be written to <code>dest</code>.</p>
<p>If <code>dest</code> is a null pointer, the call is equivalent to <code>wcrtomb_s(&amp;retval, buf, sizeof buf, L'\0', ps)</code> with internal variables <code>retval</code> and <code>buf</code> (whose size is greater than <code>MB_CUR_MAX</code>).</p>
<p>If the environment macro <b>STDC_ISO_10646</b> is defined, the values of type wchar_t are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p>
<p>If the environment macro <b>STDC_MB_MIGHT_NEQ_WC</b> is defined, then for members of the basic character set multibyte-character encoding might not equal wide-character encoding (non-ASCII-based systems, such as EBCDIC-based systems, may use Unicode for their wide character encoding and still be conforming). ASCII-based systems with <b>STDC_ISO_10646</b> defined leave <b>STDC_MB_MIGHT_NEQ_WC</b> undefined.</p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled. Also in the error cases for ESNOSPC and EILSEQ.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.6.4.1 The wctomb_s function (p: 610-611) <a href="http://en.cppreference.com/w/c/string/multibyte/wctomb">http://en.cppreference.com/w/c/string/multibyte/wctomb</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">retval</td><td>pointer to a <code>size_t</code> object where the result will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to bytes where the result will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of <code>dest</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>the wide character to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>retval shall not be a null pointer. </dd>
<dd>
dmax shall not be greater than <code>RSIZE_MAX_STR</code> (unless dest is null). </dd>
<dd>
dmax shall not equal zero (unless dest is null). </dd>
<dd>
dmax must be zero if dest is null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_STR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns zero on success and non-zero on failure, in which case, <code>dest</code>[0] is set to '\0' (unless dest is null or dmax is zero or greater than RSIZE_MAX_STR) and <code>*retval</code> is set to (size_t)-1 (unless retval is null).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful conversion. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when retval is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_STR, unless dest is NULL </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax is smaller than the number of required bytes </td></tr>
    <tr><td class="paramname">EILSEQ</td><td>if returned by wctomb()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d37/wcrtomb__s_8c.html#a45b0fbb8f40fb56bec9d9240d83907d9" title="Does not permit the ps parameter (the pointer to the conversion state) to be a null pointer...">wcrtomb_s()</a> </dd></dl>

</div>
</div>
<a id="a07831ddbabb97091c8470ee047dc9b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07831ddbabb97091c8470ee047dc9b0c">&#9670;&nbsp;</a></span>wcsnlen_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> size_t wcsnlen_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The wcsnlen_s function computes the length of the wide string pointed to by dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to wide string </td></tr>
    <tr><td class="paramname">dmax</td><td>maximum length of wide string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the wide string length, excluding the terminating null character. If <code>dest</code> is NULL, then <code>wcsnlen_s</code> returns 0. Otherwise, the <code>wcsnlen_s</code> function returns the number of wide characters that precede the terminating null character. If there is no null character in the first <code>dmax</code> characters of dest then <code>wcsnlen_s</code> returns <code>dmax</code>. At most the first <code>dmax</code> characters of dest are accessed by <code>wcsnlen_s</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d06/strnlen__s_8c.html#a72f988b24df8122611e4d6132b3f93ab" title="The strnlen_s function computes the length of the string pointed to by dest. ">strnlen_s()</a>, <a class="el" href="../../dd/de1/strnterminate__s_8c.html#ae2f83d56f2ec5cb219b7bc8961fb41b3" title="The strnterminate_s function will terminate the string if a null is not encountered before dmax chara...">strnterminate_s()</a> </dd></dl>

</div>
</div>
<a id="aed99e0d3d9effb78c6f47965460723f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed99e0d3d9effb78c6f47965460723f2">&#9670;&nbsp;</a></span>wcscpy_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcscpy_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>wcscpy_s</code> function copies the string pointed to by <code>src</code> (including the terminating null character) into the array pointed to by dest. </p>
<p>With <code>SAFECLIB_STR_NULL_SLACK</code> defined all elements following the terminating null character (if any) written by <code>wcscpy_s</code> in the array of <code>dmax</code> characters pointed to by <code>dest</code> are nulled when <code>wcscpy_s</code> returns.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.2.1.1 The wcscpy_s function (p: 639) <a href="http://en.cppreference.com/w/c/string/wide/wcscpy">http://en.cppreference.com/w/c/string/wide/wcscpy</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be replaced by src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the wide string that will be copied to dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall be greater than wcsnlen_s(src, dmax). </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then wcscpy_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, the wide characters in src were copied into dest and the result is null terminated. </td></tr>
    <tr><td class="paramname">-ESNULLP</td><td>when dest or src is a NULL pointer </td></tr>
    <tr><td class="paramname">-ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">-ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">-ESOVRLP</td><td>when buffers overlap </td></tr>
    <tr><td class="paramname">-ESNOSPC</td><td>when dest &lt; src</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>wcsncpy(), wmemcpy(), wmemmove(), <a class="el" href="../../d2/d68/strncpy__s_8c.html#a1554d39ed8b47634296e8fb86594f77e" title="The strncpy_s function copies not more than slen successive characters (characters that follow a null...">strncpy_s()</a> </dd></dl>

</div>
</div>
<a id="a13519fd510a16c6022720d90f0b360cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13519fd510a16c6022720d90f0b360cf">&#9670;&nbsp;</a></span>wcsncpy_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsncpy_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The wcsncpy_s function copies the wide string pointed to by src (including the terminating null character) into the wide string pointed to by dest. </p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written by wcsncpy_s in the array of dmax characters pointed to by dest are nulled when wcsncpy_s returns.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.2.1.2 The wcsncpy_s function (p: 639) <a href="http://en.cppreference.com/w/c/string/wide/wcsncpy">http://en.cppreference.com/w/c/string/wide/wcsncpy</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be replaced by src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the wide string that will be copied to dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum number of wide characters to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
If slen is either greater than or equal to dmax, then dmax should be more than wcsnlen_s(src,dmax) to avoid truncation. </dd>
<dd>
Copying shall not take place between objects that overlap.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then wcsncpy_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, the wide characters in src were copied into dest and the result is null terminated. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest or src is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when buffers overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dest &lt; src</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d33/wcscpy__s_8c.html#aaa7f86195bbc6387118d2d78f9813ed2" title="The wcscpy_s function copies the string pointed to by src (including the terminating null character) ...">wcscpy_s()</a>, <a class="el" href="../../d2/d68/strncpy__s_8c.html#a1554d39ed8b47634296e8fb86594f77e" title="The strncpy_s function copies not more than slen successive characters (characters that follow a null...">strncpy_s()</a>, <a class="el" href="../../d9/dd4/wmemcpy__s_8c.html#a339f33e5b2027c3e61ebf135b73328f1" title="This function copies at most smax wchar_t&#39;s from src to dest, up to dmax. ">wmemcpy_s()</a>, <a class="el" href="../../de/de6/wmemmove__s_8c.html#aa6e5e33869fa209e8e349b05fdc509ae" title="The wmemmove_s function copies smax wchar_t&#39;s from the region pointed to by src into the region point...">wmemmove_s()</a> </dd></dl>

</div>
</div>
<a id="a725971d12803e7cb5c62c476b387ac74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725971d12803e7cb5c62c476b387ac74">&#9670;&nbsp;</a></span>wcscat_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcscat_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The wcscat_s function appends a copy of the wide string pointed to by src (including the terminating null character) to the end of the wide string pointed to by dest. </p>
<p>The initial wide character from src overwrites the null character at the end of dest.</p>
<p>All elements following the terminating null wide character (if any) written by wcscat_s in the array of dmax characters pointed to by dest take unspecied values when wcscat_s returns. With SAFECLIB_STR_NULL_SLACK defined the rest is cleared with 0.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.2.1 The wcscat_s function (p: 617-618) <a href="http://en.cppreference.com/w/c/string/wide/wcscat">http://en.cppreference.com/w/c/string/wide/wcscat</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be extended by src if dmax allows. The wide string is null terminated. If the resulting concatenated wide string is less than dmax, the remaining slack space is nulled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of the resulting dest, including the null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the wide string that will be concatenaed to string dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer </dd>
<dd>
dmax shall not equal zero </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR </dd>
<dd>
dmax shall be greater than wcsnlen_s(src,m). </dd>
<dd>
Copying shall not take place between objects that overlap</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then wcscat_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, all the wide characters from src were appended to dest and the result in dest is null terminated. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest or src is a NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">ESUNTERM</td><td>when dest not terminated in the first dmax wide characters </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when src overlaps with dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d45/wcscat__s_8c.html#a6067ccb8e49740c81412be7b666c7cbc" title="The wcscat_s function appends a copy of the wide string pointed to by src (including the terminating ...">wcscat_s()</a>, <a class="el" href="../../df/d8e/strcpy__s_8c.html#aa5d4bb11f2e2390d7d8bc0593f8c0b12" title="The strcpy_s function copies the string pointed to by src (including the terminating null character) ...">strcpy_s()</a>, <a class="el" href="../../d2/d68/strncpy__s_8c.html#a1554d39ed8b47634296e8fb86594f77e" title="The strncpy_s function copies not more than slen successive characters (characters that follow a null...">strncpy_s()</a> </dd></dl>

</div>
</div>
<a id="ad28268c019a36d36840b6ea11140e7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28268c019a36d36840b6ea11140e7e0">&#9670;&nbsp;</a></span>wcsncat_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsncat_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The wcsncat_s function appends a copy of the wide string pointed to by src (including the terminating null wide character) to the end of the wide string pointed to by dest. </p>
<p>The initial character from src overwrites the null wide character at the end of dest.</p>
<p>All elements following the terminating null wide character (if any) written by wcsncat_s in the array of dmax wide characters pointed to by dest take unspecied values when wcsncat_s returns. With SAFECLIB_STR_NULL_SLACK defined the rest is cleared with 0.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.2.2 The wcsncat_s function (p: 618-620) <a href="http://en.cppreference.com/w/c/string/wide/wcsncat">http://en.cppreference.com/w/c/string/wide/wcsncat</a></li>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be extended by src if dmax allows. The string is null terminated. If the resulting concatenated wide string is less than dmax, the remaining slack space is nulled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of the resulting dest, including the null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the wide string that will be concatenaed to string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum wide characters to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer </dd>
<dd>
dmax shall not equal zero </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR </dd>
<dd>
dmax shall be greater than wcsnlen_s(src,m). </dd>
<dd>
Copying shall not takeplace between objects that overlap</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then wcsncat_s sets dest[0] to the 0 wide character. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>successful operation, all the wide characters from src null terminated. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">ESUNTERM</td><td>when dest not terminated </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when src overlaps with dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d45/wcscat__s_8c.html#a6067ccb8e49740c81412be7b666c7cbc" title="The wcscat_s function appends a copy of the wide string pointed to by src (including the terminating ...">wcscat_s()</a>, <a class="el" href="../../df/d8b/strncat__s_8c.html#a8434f897dae0bd71d5c9fa330b53afa2" title="The strncat_s function appends a copy of the string pointed to by src (including the terminating null...">strncat_s()</a> </dd></dl>

</div>
</div>
<a id="af1a2dbd151501d66b1f22706c63a25db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a2dbd151501d66b1f22706c63a25db">&#9670;&nbsp;</a></span>wcstok_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> wchar_t* wcstok_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **restrict&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of tokens, each of which is delimited by a character from the string pointed to by delim. </p>
<p>The fourth argument points to a caller-provided char pointer into which the wcstok_s function stores information necessary for it to continue scanning the same string.</p>
<p>The first call in a sequence has a non-null first argument and dmax points to an object whose value is the number of elements in the character array pointed to by the first argument. The first call stores an initial value in the object pointed to by ptr and updates the value pointed to by dmax to reect the number of elements that remain in relation to ptr. Subsequent calls in the sequence have a null first argument and the objects pointed to by dmax and ptr are required to have the values stored by the previous call in the sequence, which are then updated. The separator string pointed to by delim may be different from call to call.</p>
<p>The first call in the sequence searches the string pointed to by dest for the first character that is not contained in the current separator string pointed to by delim. If no such character is found, then there are no tokens in the string pointed to by dest and the wcstok_s function returns a null pointer. If such a character is found, it is the start of the first token.</p>
<p>The wcstok_s function then searches from there for the first character in dest that is contained in the current separator string. If no such character is found, the current token extends to the end of the string pointed to by dest, and subsequent searches in the same string for a token return a null pointer. If such a character is found, it is overwritten by a null character, which terminates the current token.</p>
<p>In all cases, the wcstok_s function stores sufcient information in the pointer pointed to by ptr so that subsequent calls, with a null pointer for dest and the unmodied pointer value for ptr, shall start searching just past the element overwritten by a null character (if any).</p>
<p>delim uses a STRTOK_DELIM_MAX_LEN of 16.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.7.3.1 The wcstok_s function (p: 620-621) <a href="http://en.cppreference.com/w/c/string/byte/strok">http://en.cppreference.com/w/c/string/byte/strok</a></li>
<li>ISO/IEC TR 24731-1, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to string to tokenize </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dmax</td><td>restricted maximum length of dest string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>pointer to delimiter string (len &lt; 255) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>returned pointer to token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>delim shall not be a null pointer. </dd>
<dd>
ptr shall not be a null pointer. </dd>
<dd>
dmax shall not be a null pointer. </dd>
<dd>
*dmax shall not be 0. </dd>
<dd>
If dest is a null pointer, then *ptr shall not be a null pointer. </dd>
<dd>
dest must not be unterminated. </dd>
<dd>
The value of *dmax shall not be greater than RSIZE_MAX_WSTR. The end of the token found shall occur within the first *dmax characters of dest for the first call, and shall occur within the first *dmax characters of where searching resumes on subsequent calls. </dd>
<dd>
delim must not be longer than STRTOK_DELIM_MAX_LEN (default: 16).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The mingw MINGW_HAS_SECURE_API declares it without the dmax argument and without restrict. Skip it there. <code>wchar_t* wcstok_s(wchar_t *str, const wchar_t *delim, wchar_t **next_token)</code></dd>
<dd>
C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The wcstok_s function returns a pointer to the first character of a token; or a null pointer if there is no token or there is a runtime-constraint violation. Each call modifies dest by substituting a wide NULL character for the first delimiter that occurs after the returned token. If there is a runtime-constraint violation, the strtok_s function does not indirect through the dest/delim pointers, and does not store a value in the object pointed to by ptr.</dd></dl>
<p>errno is set to: ESNULLP when dest/delim/ptr is NULL pointer ESZEROL when *dmax = 0 ESLEMAX when *dmax &gt; RSIZE_MAX_WSTR ESUNTERM when unterminated string C11 just returns EINVAL</p>
<dl class="section remark"><dt>Remarks</dt><dd>Example to demonstrate usage of <a class="el" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s()</a> to tokenize a string <div class="fragment"><div class="line"><span class="comment">// Approach1: sequential wcstok_s() calls</span></div><div class="line">str1 = L<span class="stringliteral">&quot;,.:*one,two;three,;four*.*.five-six***&quot;</span>; <span class="comment">// String to tokenize </span></div><div class="line"><a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a> = 38;</div><div class="line">str2 = L<span class="stringliteral">&quot;,.;*&quot;</span>; <span class="comment">// String of delimiters</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s</a>(str1, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str); </div><div class="line"><span class="comment">// token: one, remaining: two;three,;four*.*.five-six***, len: 30</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: two, remaining: three,;four*.*.five-six***, len: 26</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: three,  remaining: ;four*.*.five-six***, len: 20</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: four, remaining .*.five-six***, len: 14</span></div><div class="line"></div><div class="line">p2tok = <a class="code" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"><span class="comment">// token: five-six, remaining: **, len: 2</span></div><div class="line"></div><div class="line"> p2tok = <a class="code" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line"> <span class="comment">// token: (null), remaining: **, len: 0</span></div><div class="line"></div><div class="line"> <span class="comment">// Approach2: Use of while loop with same entry data as used above</span></div><div class="line"> p2tok = str1;</div><div class="line"> <span class="keywordflow">while</span> (p2tok &amp;&amp; <a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>) </div><div class="line"> {</div><div class="line">   p2tok = <a class="code" href="../../da/d1a/wcstok__s_8c.html#af7ed0d37e3a7ec161ae9cf29f37f2e92" title="A sequence of calls to the wcstok_s function breaks the string pointed to by dest into a sequence of ...">wcstok_s</a>(NULL, &amp;<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a>, str2, &amp;p2str);</div><div class="line">   printf(<span class="stringliteral">&quot;  token --   remaining --  len=0 \n&quot;</span>, p2tok, p2str, (<span class="keywordtype">int</span>)<a class="code" href="../../d8/dbe/towctrans_8c.html#ad4c01009aad5a218ea64c329ebfe653d">len</a> );</div><div class="line"> }</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a78ea1769556656f26090c5fe2b94aa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ea1769556656f26090c5fe2b94aa2d">&#9670;&nbsp;</a></span>swprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int swprintf_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>swprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>. </p>
<p>Instead of being printed, the content is stored in dest. With <code>SAFECLIB_STR_NULL_SLACK</code> defined all elements following the terminating null character (if any) written by <code>swprintf_s</code> in the array of dmax wide characters pointed to by <code>dest</code> are nulled when <code>swprintf_s</code> returns.</p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vswprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.4 The swprintf_s function (p: 630-631) <a href="http://en.cppreference.com/w/c/io/fwprintf">http://en.cppreference.com/w/c/io/fwprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>dest</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>dmax</code> shall not be greater than <code>RSIZE_MAX_WSTR</code>. </dd>
<dd>
<code>dmax</code> shall not equal zero. </dd>
<dd>
<code>dmax</code> shall be greater than <code>wcsnlen_s(dest, dmax)</code>. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd>
<dd>
While narrow strings provide <code>snprintf</code>, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's <code>swprintf_s</code>), and in order to determine the buffer size, the program may need to call <code>swprintf</code>, check the result value, and reallocate a larger buffer, trying again until successful.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If no runtime-constraint violation occurred, the swprintf_s function returns the number of wide characters written in the array, not counting the terminating null wide character. If an encoding error occurred or if n or more wide characters are requested to be written, swprintf_s returns a negative value. If any other runtime-constraint violation occurred, swprintf_s returns zero, and sets errno. </dd>
<dd>
If the buffer <code>dest</code> is too small for the formatted text, including the terminating null, then the buffer is set to an empty string by placing a null wide character at <code>dest</code>[0], and the invalid parameter handler is invoked.</dd></dl>
<p>errno: ESNULLP when <code>dest/fmt</code> is NULL pointer ESZEROL when <code>dmax</code> = 0 ESLEMAX when <code>dmax</code> &gt; <code>RSIZE_MAX_WSTR</code> ESNOSPC when return value exceeds dmax EINVAL when <code>fmt</code> contains <code>n</code> </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if an encoding error occurred or if n or more wide characters are requested to be written. </td></tr>
    <tr><td class="paramname">0</td><td>on some other error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d33/vswprintf__s_8c.html#ad293751332435e7b360de1b2fd1bf005" title="The vswprintf_s function composes a wide string with same test that would be printed if format was us...">vswprintf_s()</a>, <a class="el" href="../../d6/d6b/snwprintf__s_8c.html#a2994a6a76b2853b7bd59f48d02609eef" title="The truncating snwprintf_s function composes a wide string with same test that would be printed if fo...">snwprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a91e11f5eec2d7783dd8dea450121f74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e11f5eec2d7783dd8dea450121f74b">&#9670;&nbsp;</a></span>vswprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vswprintf_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vswprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>. </p>
<p>Instead of being printed, the content is stored in dest. With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written by <code>vswprintf_s</code> in the array of <code>dmax</code> wide characters pointed to by <code>dest</code> are nulled when <code>vswprintf_s</code> returns.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.9 The vswprintf_s function (p: 634-635) <a href="http://en.cppreference.com/w/c/io/vfwprintf">http://en.cppreference.com/w/c/io/vfwprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor fmt shall be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall be greater than wcsnlen_s(dest, dmax). </dd>
<dd>
fmt shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If no runtime-constraint violation occurred, the vswprintf_s function returns the number of wide characters written in the array, not counting the terminating null wide character. If an encoding error occurred or if n or more wide characters are requested to be written, vswprintf_s returns a negative value. If any other runtime-constraint violation occurred, vswprintf_s returns zero. </dd>
<dd>
If the buffer dest is too small for the formatted text, including the terminating null, then the buffer is set to an empty string by placing a null wide character at dest[0], and the invalid parameter handler is invoked. Unlike vsnprintf, vswprintf_s guarantees that the buffer will be null-terminated unless the buffer size is zero.</dd></dl>
<p>errno: ESNULLP when <code>dest/fmt</code> is NULL pointer ESZEROL when <code>dmax</code> = 0 ESLEMAX when <code>dmax</code> &gt; <code>RSIZE_MAX_WSTR</code> ESNOSPC when return value exceeds dmax EINVAL when <code>fmt</code> contains <code>n</code> EINVAL or EOVERFLOW if returned by vswprintf</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if an encoding error occurred or if n or more wide characters are requested to be written. </td></tr>
    <tr><td class="paramname">0</td><td>on some other error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d21/sprintf__s_8c.html#a2d098650aa785e976422266d4daf1682" title="The sprintf_s function composes a string with same test that would be printed if format was used on p...">sprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a7fa23a1b9bb76cbeba8848f07a0ab50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa23a1b9bb76cbeba8848f07a0ab50c">&#9670;&nbsp;</a></span>snwprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int snwprintf_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The truncating <code>snwprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>. </p>
<p>Instead of being printed, the content is stored in dest. With <code>SAFECLIB_STR_NULL_SLACK</code> defined all elements following the terminating null character (if any) written by <code>snwprintf_s</code> in the array of dmax wide characters pointed to by <code>dest</code> are nulled when <code>snwprintf_s</code> returns. Warning: Unlike the safe variant <code>swprintf_s</code>, <code>snwprintf_s</code> does not guarantee that the buffer will be null-terminated unless the buffer size is zero.</p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vswprintf</code> or <code>vsnwprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.8 The snwprintf_s function (p: 634-635) <a href="http://en.cppreference.com/w/c/io/fwprintf">http://en.cppreference.com/w/c/io/fwprintf</a></li>
<li>only included in safeclib with <code>&ndash;enable-unsafe</code> </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>dest</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>dmax</code> shall not be greater than <code>RSIZE_MAX_WSTR</code>. </dd>
<dd>
<code>dmax</code> shall not equal zero. </dd>
<dd>
<code>dmax</code> shall be greater than <code>wcsnlen_s(dest, dmax)</code>. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd>
<dd>
While narrow strings provide <code>snprintf</code>, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's <code>snwprintf_s</code>), and in order to determine the buffer size, the program may need to call <code>swprintf</code>, check the result value, and reallocate a larger buffer, trying again until successful.</dd>
<dd>
<code>snwprintf_s</code>, unlike <code>swprintf_s</code>, will truncate the result to fit within the array pointed to by buffer, even though truncation is treated as an error by most bounds-checked functions.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of wide characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd>
<dd>
If the buffer <code>dest</code> is too small for the formatted text, including the terminating null, then the buffer is set to an empty string by placing a null wide character at <code>dest</code>[0], and the invalid parameter handler is invoked. Unlike <code>snwprintf_s</code>, <code>swprintf_s</code> guarantees that the buffer will be null-terminated unless the buffer size is zero.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when <code>dest/fmt</code> is NULL pointer </td></tr>
    <tr><td class="paramname">-ESZEROL</td><td>when <code>dmax</code> = 0 </td></tr>
    <tr><td class="paramname">-ESLEMAX</td><td>when <code>dmax</code> &gt; <code>RSIZE_MAX_WSTR</code> </td></tr>
    <tr><td class="paramname">-ESNOSPC</td><td>when return value exceeds dmax </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when <code>fmt</code> contains <code>n</code> </td></tr>
    <tr><td class="paramname">-1</td><td>on some other error. errno is set then</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d33/vswprintf__s_8c.html#ad293751332435e7b360de1b2fd1bf005" title="The vswprintf_s function composes a wide string with same test that would be printed if format was us...">vswprintf_s()</a>, <a class="el" href="../../d4/d4f/swprintf__s_8c.html#a719abdc1626b4bcf6cbd9aefa0b505e9" title="The swprintf_s function composes a wide string with same test that would be printed if format was use...">swprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a0457ee1141935980d88b74321a128ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0457ee1141935980d88b74321a128ab4">&#9670;&nbsp;</a></span>vsnwprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vsnwprintf_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The truncating <code>vsnwprintf_s</code> function composes a wide string with same test that would be printed if format was used on <code>wprintf</code>. </p>
<p>Instead of being printed, the content is stored in dest. With <code>SAFECLIB_STR_NULL_SLACK</code> defined all elements following the terminating null character (if any) written by <code>vsnwprintf_s</code> in the array of dmax wide characters pointed to by <code>dest</code> are nulled when <code>vsnwprintf_s</code> returns. Warning: Unlike the safe variant <code>vswprintf_s</code>, <code>vsnwprintf_s</code> does not guarantee that the buffer will be null-terminated unless the buffer size is zero.</p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vswprintf</code> or <code>vsnwprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.8 The vsnwprintf_s function (p: 634-635) <a href="http://en.cppreference.com/w/c/io/vfwprintf">http://en.cppreference.com/w/c/io/vfwprintf</a></li>
<li>only included in safeclib with <code>&ndash;enable-unsafe</code> </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to wide string that will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor fmt shall be a null pointer. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR. </dd>
<dd>
dmax shall not equal zero. </dd>
<dd>
dmax shall be greater than wcsnlen_s(dest, dmax). </dd>
<dd>
fmt shall not contain the conversion specifier n </dd>
<dd>
None of the arguments corresponding to s is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C11 uses RSIZE_MAX, not RSIZE_MAX_WSTR.</dd>
<dd>
While narrow strings provide <code>snprintf</code>, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's <code>snwprintf_s</code>), and in order to determine the buffer size, the program may need to call <code>swprintf</code>, check the result value, and reallocate a larger buffer, trying again until successful.</dd>
<dd>
<code>snwprintf_s</code>, unlike <code>swprintf_s</code>, will truncate the result to fit within the array pointed to by buffer, even though truncation is treated as an error by most bounds-checked functions.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of wide characters written is returned. </dd>
<dd>
On failure a negative number is returned. </dd>
<dd>
If the buffer dest is too small for the formatted text, including the terminating null, then the buffer is set to an empty string by placing a null wide character at dest[0], and the invalid parameter handler is invoked. Unlike <code>vsnwprintf</code>, <code>vswprintf_s</code> guarantees that the buffer will be null-terminated unless the buffer size is zero.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">-ESNULLP</td><td>when dest/fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>on some other error. errno is set then</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d33/vswprintf__s_8c.html#ad293751332435e7b360de1b2fd1bf005" title="The vswprintf_s function composes a wide string with same test that would be printed if format was us...">vswprintf_s()</a>, <a class="el" href="../../d6/d6b/snwprintf__s_8c.html#a2994a6a76b2853b7bd59f48d02609eef" title="The truncating snwprintf_s function composes a wide string with same test that would be printed if fo...">snwprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a390b28c7682a043fd97c142e4d3906f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390b28c7682a043fd97c142e4d3906f4">&#9670;&nbsp;</a></span>wprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int wprintf_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The wprintf_s function prints formatted output to stdout as wide string. </p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vwprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.13 The wprintf_s function (p: 637-638) <a href="http://en.cppreference.com/w/c/io/fwprintf">http://en.cppreference.com/w/c/io/fwprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>fmt shall not be a null pointer. </dd>
<dd>
fmt shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of wide characters written is returned. </dd>
<dd>
On failure a negative number is returned, and possibly errno set to EINVAL or EOVERFLOW.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>some other error. errno: EINVAL or EOVERFLOW</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>vwfprintf_s(), <a class="el" href="../../de/d97/fwprintf__s_8c.html#a8fdc38563b8b8a375ab10cee2d99af11" title="The fwprintf_s function prints formatted output to a wide stream. ">fwprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a360e076fff606b3767da440b220eb39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360e076fff606b3767da440b220eb39b">&#9670;&nbsp;</a></span>vwprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vwprintf_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The vwprintf_s function prints formatted output to stdout as wide string. </p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.11 The vwprintf_s function (p: 636) <a href="http://en.cppreference.com/w/c/io/vfwprintf">http://en.cppreference.com/w/c/io/vfwprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fmt</code> shall not be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of wide characters written is returned. </dd>
<dd>
On failure a negative number is returned, and possibly errno set to EINVAL or EOVERFLOW.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>some other error. errno: EINVAL or EOVERFLOW</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>vwfprintf_s(), <a class="el" href="../../d4/d33/wprintf__s_8c.html#ad050a81d212ded6a7b6947ba53218cdd" title="The wprintf_s function prints formatted output to stdout as wide string. ">wprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a4bd405ffe5ad436fbe18ff80da8dcf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd405ffe5ad436fbe18ff80da8dcf16">&#9670;&nbsp;</a></span>fwprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int fwprintf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The fwprintf_s function prints formatted output to a wide stream. </p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vfwprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.6 The fwprintf_s function (p: 632) <a href="http://en.cppreference.com/w/c/io/vfwprintf">http://en.cppreference.com/w/c/io/vfwprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>output wide stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>fmt shall not be a null pointer. </dd>
<dd>
fmt shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of wide characters written is returned. </dd>
<dd>
On failure a negative number is returned, and possibly errno set to EINVAL or EOVERFLOW.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when fmt is NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>some other error. errno: EINVAL or EOVERFLOW</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>vwfprintf_s(), <a class="el" href="../../d4/d33/wprintf__s_8c.html#ad050a81d212ded6a7b6947ba53218cdd" title="The wprintf_s function prints formatted output to stdout as wide string. ">wprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a2c3f8921f47a6e50005ad675109f207f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3f8921f47a6e50005ad675109f207f">&#9670;&nbsp;</a></span>vfwprintf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vfwprintf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The vfwprintf_s function prints formatted output to a wide stream. </p>
<dl class="section note"><dt>Note</dt><dd>POSIX specifies that <code>errno</code> is set on error. However, the safeclib extended <code>ES*</code> errors do not set <code>errno</code>, only when the underlying system <code>vfwprintf</code> call fails, <code>errno</code> is set.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.6 The vfwprintf_s function (p: 632) <a href="http://en.cppreference.com/w/c/io/vfwprintf">http://en.cppreference.com/w/c/io/vfwprintf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>output wide stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>optional arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither stream nor fmt shall be a null pointer. </dd>
<dd>
fmt shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer (not yet) </dd>
<dd>
No encoding error shall occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success the total number of wide characters written is returned. </dd>
<dd>
On failure a negative number is returned, and possibly errno set to EINVAL or EOVERFLOW.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ESNULLP</td><td>when stream or fmt is a NULL pointer </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>when fmt contains n </td></tr>
    <tr><td class="paramname">-1</td><td>some other error. errno: EINVAL or EOVERFLOW</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d00/vfwscanf__s_8c.html#a9dc6f2ac722aad499e5ffd1d515a4d5b" title="The vfwscanf_s function reads a formatted wide string. ">vfwscanf_s()</a>, <a class="el" href="../../de/d97/fwprintf__s_8c.html#a8fdc38563b8b8a375ab10cee2d99af11" title="The fwprintf_s function prints formatted output to a wide stream. ">fwprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a96a093e276412353fcb09dab51b2c732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a093e276412353fcb09dab51b2c732">&#9670;&nbsp;</a></span>swscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int swscanf_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>swscanf_s</code> function reads a formatted wide string. </p>
<p>Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.5 The swscanf_s function (p: 631) <a href="http://en.cppreference.com/w/c/io/fwscanf">http://en.cppreference.com/w/c/io/fwscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to a null-terminated wide string to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>buffer</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>lc</code> into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d9a/vswscanf__s_8c.html#ad5d12da65d550624489545ed32403cbf" title="The vswscanf_s function reads a formatted wide string. ">vswscanf_s()</a>, <a class="el" href="../../d6/d6b/snwprintf__s_8c.html#a2994a6a76b2853b7bd59f48d02609eef" title="The truncating snwprintf_s function composes a wide string with same test that would be printed if fo...">snwprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="aae5b8d45187ca36d5a986bd54abefb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5b8d45187ca36d5a986bd54abefb53">&#9670;&nbsp;</a></span>vswscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vswscanf_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vswscanf_s</code> function reads a formatted wide string. </p>
<p>Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.10 The vswscanf_s function (p: 635-636) <a href="http://en.cppreference.com/w/c/io/vfwscanf">http://en.cppreference.com/w/c/io/vfwscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to a null-terminated wide string to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>buffer</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>lc</code> into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d9a/vswscanf__s_8c.html#ad5d12da65d550624489545ed32403cbf" title="The vswscanf_s function reads a formatted wide string. ">vswscanf_s()</a>, <a class="el" href="../../d6/d6b/snwprintf__s_8c.html#a2994a6a76b2853b7bd59f48d02609eef" title="The truncating snwprintf_s function composes a wide string with same test that would be printed if fo...">snwprintf_s()</a>, <a class="el" href="../../db/d8d/vsnprintf__s_8c.html#a59ed915174ea1f259742749f64549e55" title="The truncating vsnprintf_s function composes a string with same test that would be printed if format ...">vsnprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a9dc67e003c3fc2a77921af9a657304d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc67e003c3fc2a77921af9a657304d1">&#9670;&nbsp;</a></span>wscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int wscanf_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>wscanf_s</code> function reads a formatted wide string from stdin. </p>
<p>Reaching the end of the stdin buffer is equivalent to reaching the end-of-file condition for <code>wscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.14 The wscanf_s function (p: 638) <a href="http://en.cppreference.com/w/c/io/wscanf">http://en.cppreference.com/w/c/io/wscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>lc</code> into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d9a/vswscanf__s_8c.html#ad5d12da65d550624489545ed32403cbf" title="The vswscanf_s function reads a formatted wide string. ">vswscanf_s()</a>, <a class="el" href="../../d3/d42/fwscanf__s_8c.html#a980109ae08a082f7658918f49bb9be16" title="The fwscanf_s function reads a formatted wide string. ">fwscanf_s()</a>, <a class="el" href="../../d4/d00/vfwscanf__s_8c.html#a9dc6f2ac722aad499e5ffd1d515a4d5b" title="The vfwscanf_s function reads a formatted wide string. ">vfwscanf_s()</a>, <a class="el" href="../../d4/dd5/vfwprintf__s_8c.html#abd998918fd5ab94982c1b7841ab001d5" title="The vfwprintf_s function prints formatted output to a wide stream. ">vfwprintf_s()</a> </dd></dl>

</div>
</div>
<a id="ad0f67a9930496e53ce6af7451956893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f67a9930496e53ce6af7451956893d">&#9670;&nbsp;</a></span>vwscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vwscanf_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vwscanf_s</code> function reads a formatted wide string from stdin. </p>
<p>Reaching the end of the stdin buffer is equivalent to reaching the end-of-file condition for <code>vwscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.12 The vwscanf_s function (p: 637) <a href="http://en.cppreference.com/w/c/io/vwscanf">http://en.cppreference.com/w/c/io/vwscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ap</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>stream</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>lc</code> into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d9a/vswscanf__s_8c.html#ad5d12da65d550624489545ed32403cbf" title="The vswscanf_s function reads a formatted wide string. ">vswscanf_s()</a>, <a class="el" href="../../d5/ddd/wscanf__s_8c.html#a5f12063f66169a180488102015ce6da0" title="The wscanf_s function reads a formatted wide string from stdin. ">wscanf_s()</a>, vvwscanf_s(), <a class="el" href="../../d4/dd5/vfwprintf__s_8c.html#abd998918fd5ab94982c1b7841ab001d5" title="The vfwprintf_s function prints formatted output to a wide stream. ">vfwprintf_s()</a> </dd></dl>

</div>
</div>
<a id="ab1b0c51d92250649124c09c6cabda5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b0c51d92250649124c09c6cabda5b0">&#9670;&nbsp;</a></span>fwscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int fwscanf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>fwscanf_s</code> function reads a formatted wide string. </p>
<p>Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.7 The fwscanf_s function (p: 632-633) <a href="http://en.cppreference.com/w/c/io/fwscanf">http://en.cppreference.com/w/c/io/fwscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>pointer to a FILE stream to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>stream</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) Note it currently even crashes with a NULL pointer. </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>lc</code> into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d9a/vswscanf__s_8c.html#ad5d12da65d550624489545ed32403cbf" title="The vswscanf_s function reads a formatted wide string. ">vswscanf_s()</a>, <a class="el" href="../../d5/ddd/wscanf__s_8c.html#a5f12063f66169a180488102015ce6da0" title="The wscanf_s function reads a formatted wide string from stdin. ">wscanf_s()</a>, <a class="el" href="../../d4/d00/vfwscanf__s_8c.html#a9dc6f2ac722aad499e5ffd1d515a4d5b" title="The vfwscanf_s function reads a formatted wide string. ">vfwscanf_s()</a>, <a class="el" href="../../d4/dd5/vfwprintf__s_8c.html#abd998918fd5ab94982c1b7841ab001d5" title="The vfwprintf_s function prints formatted output to a wide stream. ">vfwprintf_s()</a> </dd></dl>

</div>
</div>
<a id="a283406eecc0fb4828affaf7e1017ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283406eecc0fb4828affaf7e1017ac50">&#9670;&nbsp;</a></span>vfwscanf_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int vfwscanf_s </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>vfwscanf_s</code> function reads a formatted wide string. </p>
<p>Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>SPECIFIED IN<ul>
<li>C11 standard (ISO/IEC 9899:2011): K.3.9.1.7 The vfwscanf_s function (p: 632-633) <a href="http://en.cppreference.com/w/c/io/vfwscanf">http://en.cppreference.com/w/c/io/vfwscanf</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>pointer to a FILE stream to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format-control wide string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ap</td><td>arguments to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>stream</code> nor <code>fmt</code> shall be a null pointer. </dd>
<dd>
<code>fmt</code> shall not contain the conversion specifier <code>n</code> </dd>
<dd>
None of the arguments corresponding to <code>s</code> is a null pointer. (not yet) </dd>
<dd>
No encoding error shall occur. </dd>
<dd>
<code>c</code>, <code>s</code>, and <code>%</code>[ conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a <code>lc</code> into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned or if there is a runtime constraint violation.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000001">Todo:</a></b></dt><dd>When an argument is not assigned to, it should be zero'd (not yet).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0 on success, the number of arguments assigned </td></tr>
    <tr><td class="paramname">EOF</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d9a/vswscanf__s_8c.html#ad5d12da65d550624489545ed32403cbf" title="The vswscanf_s function reads a formatted wide string. ">vswscanf_s()</a>, <a class="el" href="../../d3/d42/fwscanf__s_8c.html#a980109ae08a082f7658918f49bb9be16" title="The fwscanf_s function reads a formatted wide string. ">fwscanf_s()</a>, <a class="el" href="../../d4/dd5/vfwprintf__s_8c.html#abd998918fd5ab94982c1b7841ab001d5" title="The vfwprintf_s function prints formatted output to a wide stream. ">vfwprintf_s()</a> </dd></dl>

</div>
</div>
<a id="abf72c3bb30ce5adb59114e98924a7f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf72c3bb30ce5adb59114e98924a7f18">&#9670;&nbsp;</a></span>wcsstr_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsstr_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **restrict&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="../../dd/df8/wcsstr__s_8c.html#ac5149ef531b176db7a27bde6ff1bbf2e" title="The wcsstr_s() function locates the first occurrence of the wide substring pointed to by src which wo...">wcsstr_s()</a> function locates the first occurrence of the wide substring pointed to by src which would be located in the wide string pointed to by dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO<ul>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>wide string to be searched for the substring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the wide sub string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>the maximum number of wide characters to use from src </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">substring</td><td>the returned substring pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
Neither dmax nor slen shall not be 0. </dd>
<dd>
Neither dmax nor slen shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful operation, substring found. </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/substring is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/slen &gt; RSIZE_MAX_STR </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>when substring not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/df5/wcsstr_8c.html#ab86b2368af773580d2ee2fb27a56be09" title="The wcsstr() function locates the first occurrence of the wide substring pointed to by src which woul...">wcsstr()</a>, <a class="el" href="../../db/dc3/strstr__s_8c.html#afe35931c44fd83a3ff820e2570005beb" title="The strstr_s() function locates the first occurrence of the substring pointed to by src which would b...">strstr_s()</a>, <a class="el" href="../../de/df0/memcmp32__s_8c.html#ab3aabab114bed0d9646abd02e661d078" title="Compares memory until they differ, and their difference is returned in diff. ">memcmp32_s()</a> </dd></dl>

</div>
</div>
<a id="aa822b7efba53861a233dcee6651178a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa822b7efba53861a233dcee6651178a8">&#9670;&nbsp;</a></span>wcscmp_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcscmp_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>smax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares wide string src to wide string dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>wide string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of wide string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string to be compared to dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smax</td><td>restricted maximum length of wide string src </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>pointer to result diff, greater than 0, equal to 0 or less than 0, if the dest is greater than, equal to or less than src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
diff shall not be a null pointer. </dd>
<dd>
dmax/smax shall not be 0 </dd>
<dd>
dmax/smax shall not be greater than RSIZE_MAX_WSTR</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/diff is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/smax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/smax &gt; RSIZE_MAX_WSTR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d7b/strcmp__s_8c.html#a1af73c8a0a8e2f7abc5a1a78f154fa8e" title="Compares string src to string dest. ">strcmp_s()</a>, <a class="el" href="../../de/d15/wcsncmp__s_8c.html#a09ffbcf6eb202b718ac7af4e2a6a01b6" title="Compares at most count wide characters of wide string src with wide string dest. ">wcsncmp_s()</a>, <a class="el" href="../../d6/d6c/wcsicmp__s_8c.html#a99ca6c84ad44dd60446ec9a73e059a98" title="Compares two wide strings case-folded, via wcsfc_s(), i.e. ">wcsicmp_s()</a> </dd></dl>

</div>
</div>
<a id="a039ed28ddc950839174ae1994ec32b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039ed28ddc950839174ae1994ec32b56">&#9670;&nbsp;</a></span>wcsncmp_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsncmp_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>smax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares at most count wide characters of wide string src with wide string dest. </p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>wide string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of wide string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string to be compared to dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smax</td><td>restricted maximum length of wide string src </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>maximum number of wide characters to compare </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>pointer to result diff, greater than 0, equal to 0 or less than 0, if the dest is greater than, equal to or less than src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
diff shall not be a null pointer. </dd>
<dd>
dmax/smax shall not be 0 </dd>
<dd>
dmax/smax shall not be greater than RSIZE_MAX_WSTR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>diff (when the return code is OK) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>when dest greater than src </td></tr>
    <tr><td class="paramname">0</td><td>when wide strings the same </td></tr>
    <tr><td class="paramname">&lt;0</td><td>when dest less than src </td></tr>
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/diff is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/smax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/smax &gt; RSIZE_MAX_WSTR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d7b/strcmp__s_8c.html#a1af73c8a0a8e2f7abc5a1a78f154fa8e" title="Compares string src to string dest. ">strcmp_s()</a>, <a class="el" href="../../d1/dbf/wcscmp__s_8c.html#a828628cf15c596c2ff5165cd7d2a2cab" title="Compares wide string src to wide string dest. ">wcscmp_s()</a> </dd></dl>

</div>
</div>
<a id="a079058b84cb9b4ecd989d5a8be844fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079058b84cb9b4ecd989d5a8be844fa4">&#9670;&nbsp;</a></span>wcsicmp_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsicmp_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>smax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two wide strings case-folded, via <code><a class="el" href="../../d9/d47/wcsfc__s_8c.html#a692cc4f6619a725907aa0b227f443950" title="Converts the wide string via full case-folding NFD normalized to lowercase. ">wcsfc_s()</a></code>, i.e. </p>
<p>case-folded and normalized, and returns if difference in the last parameter. The two strings may overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>wide string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of wide string dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string to be compared to dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smax</td><td>restricted maximum length of wide string src </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>pointer to result diff, greater than 0, equal to 0 or less than 0, if the dest is greater than, equal to or less than src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
diff shall not be a null pointer. </dd>
<dd>
dmax/smax shall not be 0 </dd>
<dd>
dmax/smax shall not be greater than RSIZE_MAX_WSTR</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/diff is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/smax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/smax &gt; RSIZE_MAX_WSTR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d7b/strcmp__s_8c.html#a1af73c8a0a8e2f7abc5a1a78f154fa8e" title="Compares string src to string dest. ">strcmp_s()</a>, <a class="el" href="../../d1/dbf/wcscmp__s_8c.html#a828628cf15c596c2ff5165cd7d2a2cab" title="Compares wide string src to wide string dest. ">wcscmp_s()</a>, <a class="el" href="../../de/d15/wcsncmp__s_8c.html#a09ffbcf6eb202b718ac7af4e2a6a01b6" title="Compares at most count wide characters of wide string src with wide string dest. ">wcsncmp_s()</a>, <a class="el" href="../../d9/d47/wcsfc__s_8c.html#a692cc4f6619a725907aa0b227f443950" title="Converts the wide string via full case-folding NFD normalized to lowercase. ">wcsfc_s()</a> </dd></dl>

</div>
</div>
<a id="a3a5d4da1de92882c5e14473007cd1d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5d4da1de92882c5e14473007cd1d2e">&#9670;&nbsp;</a></span>wcsset_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsset_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets maximal dmax wide characters of dest to a wide character value, but not the final NULL character. </p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax wide characters pointed to by dest are nulled.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO<ul>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
<li>Implemented in the Windows secure API as _wcsset_s()</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string that will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>wide character value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d0c/wcsnset__s_8c.html#a2e80982de4fc741d488f6086e0880ce4" title="Sets maximal n wide characters of dest to a wide character value, but not the final NULL character...">wcsnset_s()</a>, wmemset_s(), <a class="el" href="../../d8/d88/strzero__s_8c.html#a8f450ba4c1ab7a4a7471b9be7007ae03" title="Nulls maximal dmax characters of dest. ">strzero_s()</a>, <a class="el" href="../../da/d45/strnset__s_8c.html#ac8ee0f7bddb6dd004118488a4fef6b85" title="Sets maximal n characters of dest to a character value, but not the final NULL character. ">strnset_s()</a>, <a class="el" href="../../d2/d08/strispassword__s_8c.html#acf0187b8c0aeb42c265ea1a79e5ccab9" title="This function validates the make-up of a password string. ">strispassword_s()</a> </dd></dl>

</div>
</div>
<a id="a736f4779804a3b2b64cc343daab842f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736f4779804a3b2b64cc343daab842f5">&#9670;&nbsp;</a></span>wcsnset_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsnset_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets maximal n wide characters of dest to a wide character value, but not the final NULL character. </p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax wide characters pointed to by dest are nulled.</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO<ul>
<li>ISO/IEC TR 24731, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</li>
<li>Implemented in the Windows secure API as _wcsnset_s()</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string that will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>wide character value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of wide characters to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>when successful </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR or value &gt; max wchar_t </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when n &gt; dmax</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d36/wcsset__s_8c.html#aedea5d0ad0fffe17dace7a95bfa1a43e" title="Sets maximal dmax wide characters of dest to a wide character value, but not the final NULL character...">wcsset_s()</a>, wmemset_s(), <a class="el" href="../../d8/d88/strzero__s_8c.html#a8f450ba4c1ab7a4a7471b9be7007ae03" title="Nulls maximal dmax characters of dest. ">strzero_s()</a>, <a class="el" href="../../da/d45/strnset__s_8c.html#ac8ee0f7bddb6dd004118488a4fef6b85" title="Sets maximal n characters of dest to a character value, but not the final NULL character. ">strnset_s()</a>, <a class="el" href="../../d2/d08/strispassword__s_8c.html#acf0187b8c0aeb42c265ea1a79e5ccab9" title="This function validates the make-up of a password string. ">strispassword_s()</a> </dd></dl>

</div>
</div>
<a id="ab02e31cc793591dcc0347f218cacced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02e31cc793591dcc0347f218cacced2">&#9670;&nbsp;</a></span>wcscoll_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcscoll_s </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>smax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two null-terminated wide strings according to the current locale as defined by the <code>LC_COLLATE</code> category. </p>
<p>Collation order is the dictionary order: the position of the letter in the national alphabet (its equivalence class) has higher priority than its case or variant. Within an equivalence class, lowercase characters collate before their uppercase equivalents and locale-specific order may apply to the characters with diacritics. In some locales, groups of characters compare as single collation units. For example, "ch" in Czech follows "h" and precedes "i", and "dzs" in Hungarian follows "dz" and precedes "g".</p>
<dl class="section remark"><dt>Remarks</dt><dd>EXTENSION TO ISO/IEC JTC1 SC22 WG14 N1172, Programming languages, environments and system software interfaces, Extensions to the C Library, Part I: Bounds-checking interfaces</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>wide string to compare against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>restricted maximum length of dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string to be compared to dest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smax</td><td>restricted maximum length of src </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indicator</td><td>pointer to result indicator, greater than 0, equal to 0 or less than 0, if the string pointed to by dest is greater than, equal to or less than the string pointed to by src respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither dest nor src shall be a null pointer. </dd>
<dd>
indicator shall not be a null pointer. </dd>
<dd>
dmax/smax shall not be 0 </dd>
<dd>
dmax/smax shall not be greater than RSIZE_MAX_WSTR</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>indicator (when the return code is OK) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>when dest greater than src </td></tr>
    <tr><td class="paramname">0</td><td>when strings the same </td></tr>
    <tr><td class="paramname">&lt;0</td><td>when dest less than src </td></tr>
    <tr><td class="paramname">EOK</td><td>when comparison is complete </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest/src/indicator is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax/smax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax/smax &gt; RSIZE_MAX_WSTR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dbf/wcscmp__s_8c.html#a828628cf15c596c2ff5165cd7d2a2cab" title="Compares wide string src to wide string dest. ">wcscmp_s()</a>, <a class="el" href="../../d4/d50/strcoll__s_8c.html#a1bff30eadaeb278d7556c3e2c06b06e0" title="Compares two null-terminated byte strings according to the current locale as defined by the LC_COLLAT...">strcoll_s()</a>, <a class="el" href="../../d4/d7c/strcasecmp__s_8c.html#ae11b6060ef450062df8082045083bec1" title="Case insensitive string comparison by converting to uppercase prior to the compare. ">strcasecmp_s()</a> </dd></dl>

</div>
</div>
<a id="a7a758ea56cc6e264c7be20fad0b0e96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a758ea56cc6e264c7be20fad0b0e96d">&#9670;&nbsp;</a></span>wcslwr_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcslwr_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the string converting uppercase characters to simple lowercase, leaving all other characters unchanged. </p>
<p>The scanning stops at the first null or after slen characters. The conversion is determined by the LC_CTYPE category setting of the locale. Other characters are not affected. It only performs simple case folding via <code><a class="el" href="../../d8/d67/wcslwr__s_8c.html#a99e40a22bbdac9828b3a5afecf144b8a">towlower()</a></code>, it does not do full multi-char folding and does not obey the special casing rules for context. Thus the length of buffer stays the same. It returns a pointer to the altered string. Because the modification is done in place, the pointer returned is the same as the pointer passed as the input argument.</p>
<dl class="section remark"><dt>Remarks</dt><dd>IMPLEMENTED IN<ul>
<li>Microsoft Windows Secure API</li>
<li>Novell NDK</li>
<li>Nokia openc s60.com</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">src</td><td>wide string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src shall not be a null pointer. </dd>
<dd>
slen shall not equal zero. </dd>
<dd>
slen shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when slen &gt; RSIZE_MAX_WSTR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d47/wcsfc__s_8c.html#a692cc4f6619a725907aa0b227f443950" title="Converts the wide string via full case-folding NFD normalized to lowercase. ">wcsfc_s()</a>, <a class="el" href="../../d3/d0c/strtolowercase__s_8c.html#ac2888d3274e303d743f0edb158436dfa" title="Scans the string converting uppercase characters to lowercase, leaving all other characters unchanged...">strtolowercase_s()</a>, <a class="el" href="../../d8/dff/safe__str__lib_8h.html#a680ec7c15269eddc82121895650a737a">strlwr_s()</a>, <a class="el" href="../../d7/dbb/wcsupr__s_8c.html#ad06be943f400324463015330d586479e" title="Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged...">wcsupr_s()</a> </dd></dl>

</div>
</div>
<a id="ab9c4be91bfb2f09257359dac2c3d79e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c4be91bfb2f09257359dac2c3d79e4">&#9670;&nbsp;</a></span>wcsupr_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsupr_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>slen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged. </p>
<p>The scanning stops at the first null or after slen characters. The conversion is determined by the LC_CTYPE category setting of the locale. Other characters are not affected. It converts only single chars via <code><a class="el" href="../../d8/dbe/towctrans_8c.html#a4f34aecc26d74e8ab8aa14e1995910b9">towupper()</a></code>. It returns a pointer to the altered string. Because the modification is done in place, the pointer returned is the same as the pointer passed as the input argument.</p>
<dl class="section remark"><dt>Remarks</dt><dd>IMPLEMENTED IN<ul>
<li>Microsoft Windows Secure API</li>
<li>Novell NDK</li>
<li>Nokia openc s60.com</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">src</td><td>wide string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slen</td><td>maximum length of string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src shall not be a null pointer. </dd>
<dd>
slen shall not equal zero. </dd>
<dd>
slen shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when slen = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when slen &gt; RSIZE_MAX_WSTR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d6f/strtouppercase__s_8c.html#a16c5f6402d37729b8598969dc25cb8d2" title="Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged...">strtouppercase_s()</a>, <a class="el" href="../../d8/dff/safe__str__lib_8h.html#a680ec7c15269eddc82121895650a737a">strlwr_s()</a>, <a class="el" href="../../d8/d67/wcslwr__s_8c.html#ab69dbdc53fa8ddebff72b3f16250ec7d" title="Scans the string converting uppercase characters to simple lowercase, leaving all other characters un...">wcslwr_s()</a> </dd></dl>

</div>
</div>
<a id="abce699d737a73dcdbcdd2355460bfd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce699d737a73dcdbcdd2355460bfd18">&#9670;&nbsp;</a></span>iswfc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int iswfc </td>
          <td>(</td>
          <td class="paramtype">wint_t&#160;</td>
          <td class="paramname"><em>wc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe56564b1f33f33e0d98ff9597d66c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe56564b1f33f33e0d98ff9597d66c58">&#9670;&nbsp;</a></span>towfc_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> int towfc_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wint_t&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="../../dc/d32/towfc__s_8c.html#a641c8489795192bd197158bb662de3c3" title="towfc_s() converts a wide character to fully fold-cased (lowercased with possible expansions)...">towfc_s()</a></code> converts a wide character to fully fold-cased (lowercased with possible expansions), according to the Unicode 10.0 CaseFolding table. </p>
<p>Even in most the unsuccessul cases, just not with with ESNULLP and ESZEROL dest is being written to.</p>
<p>As of Unicode 10.0 there are no possible results as surrogate pairs with <code>sizeof(wchar_t)==2</code>, all results are below U+FFFF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string buffer to store result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum size of dest, should be 4. (3 + NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide character to convert to lowercase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest shall not be a null pointer. </dd>
<dd>
dmax shall be bigger than 3 </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;=0</td><td>on successful operation, returns the number of converted wide characters: 0-3 </td></tr>
    <tr><td class="paramname">-ESNULLP</td><td>when dest is NULL pointer </td></tr>
    <tr><td class="paramname">-ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">-ESLEMIN</td><td>when dmax &lt; 4 </td></tr>
    <tr><td class="paramname">-ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">-ESNOTFND</td><td>when no mapping for src was found, iswfc is wrong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d32/towfc__s_8c.html#ae1181e32e32d8033baab847608b84c00">iswfc()</a>, <a class="el" href="../../d9/d47/wcsfc__s_8c.html#a692cc4f6619a725907aa0b227f443950" title="Converts the wide string via full case-folding NFD normalized to lowercase. ">wcsfc_s()</a>, <a class="el" href="../../d8/dbe/towctrans_8c.html#a64130b4edd82cc2a8cfcdbf4da8cc6ce">towlower()</a> </dd></dl>

</div>
</div>
<a id="ace20c4b157616ba08041aaf95fafd0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace20c4b157616ba08041aaf95fafd0b5">&#9670;&nbsp;</a></span>wcsfc_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsfc_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict&#160;</td>
          <td class="paramname"><em>lenp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the wide string via full case-folding NFD normalized to lowercase. </p>
<p>The conversion stops at the first null or after dmax characters. The conversion is determined by the LC_CTYPE category setting of the locale. Other characters are not affected. fold-case performs full case folding, i.e. if <a class="el" href="../../dc/d32/towfc__s_8c.html#ae1181e32e32d8033baab847608b84c00">iswfc()</a> of a character &gt; 1, the length of dest might be greater than the length of src (max 4 per char), the conversion is done via <code><a class="el" href="../../dc/d32/towfc__s_8c.html#a641c8489795192bd197158bb662de3c3" title="towfc_s() converts a wide character to fully fold-cased (lowercased with possible expansions)...">towfc_s()</a></code> and Unicode 10.0, the Unicode special-casing rules are obeyed, and composed characters are normalized to NFD via <code><a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a5e12aa6178b1e2084a8c7cf89b882772" title="Converts the wide string to the canonical NFD normalization, as defined in the latest Unicode standar...">wcsnorm_decompose_s()</a></code> and <code><a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a5b6c4b1185cf5dcb07fc0e2b4785e7c6" title="Reorder all decomposed sequences in a wide string to NFD, as defined in the latest Unicode standard...">wcsnorm_reorder_s()</a></code>. If not, the conversion is per character done via normal <code><a class="el" href="../../d8/dbe/towctrans_8c.html#a64130b4edd82cc2a8cfcdbf4da8cc6ce">towlower()</a></code>. Note that decomposition creates larger strings, typically 2-3 chars more.</p>
<p>With SAFECLIB_STR_NULL_SLACK defined all elements following the terminating null character (if any) written in the array of dmax characters pointed to by dest are nulled.</p>
<p>SpecialCasing checks for conditional boundary context at the begin or end of certain characters (final greek sigma), and locale sensitive rules for the Lithuanian and the Turkish/Azeri I-dot.</p>
<p>Composed characters are checked for the left-hand-side of the Decomposition_Mapping Unicode property, which means the codepoint will be normalized to NFD if any codepoint is composed. Technically only FCD as all FC expansions are already properly ordered, and all mangled marks will not be reordered, as the have the same Combining Class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string to hold the result (~130% larger than src) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum result buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lenp</td><td>pointer to length of the result, may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest and src shall not be null pointers. </dd>
<dd>
dmax shall not be smaller than 5 and big enough for dest. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on successful operation </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest or src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR or a cp &gt; 0x10ffff </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax is too small for the decomposition. *lenp is still written, to know how much space is needed. </td></tr>
    <tr><td class="paramname">ESNOTFND</td><td>Internal error as returned by <a class="el" href="../../dc/d32/towfc__s_8c.html#a641c8489795192bd197158bb662de3c3" title="towfc_s() converts a wide character to fully fold-cased (lowercased with possible expansions)...">towfc_s()</a> for multi-char foldings. happens only when the internal implementations of <a class="el" href="../../dc/d32/towfc__s_8c.html#ae1181e32e32d8033baab847608b84c00">iswfc()</a> and <a class="el" href="../../dc/d32/towfc__s_8c.html#a641c8489795192bd197158bb662de3c3" title="towfc_s() converts a wide character to fully fold-cased (lowercased with possible expansions)...">towfc_s()</a> are mismatched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d32/towfc__s_8c.html#ae1181e32e32d8033baab847608b84c00">iswfc()</a>, <a class="el" href="../../dc/d32/towfc__s_8c.html#a641c8489795192bd197158bb662de3c3" title="towfc_s() converts a wide character to fully fold-cased (lowercased with possible expansions)...">towfc_s()</a>, <a class="el" href="../../d8/dbe/towctrans_8c.html#a4f34aecc26d74e8ab8aa14e1995910b9">towupper()</a>, <a class="el" href="../../d8/d67/wcslwr__s_8c.html#ab69dbdc53fa8ddebff72b3f16250ec7d" title="Scans the string converting uppercase characters to simple lowercase, leaving all other characters un...">wcslwr_s()</a>, <a class="el" href="../../d7/dbb/wcsupr__s_8c.html#ad06be943f400324463015330d586479e" title="Scans the string converting lowercase characters to uppercase, leaving all other characters unchanged...">wcsupr_s()</a> </dd></dl>

</div>
</div>
<a id="a231a238a9b9c9efef492ea937f9ab98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231a238a9b9c9efef492ea937f9ab98e">&#9670;&nbsp;</a></span>wcsnorm_decompose_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsnorm_decompose_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict&#160;</td>
          <td class="paramname"><em>lenp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>iscompat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the wide string to the canonical NFD normalization, as defined in the latest Unicode standard, latest 10.0. </p>
<p>The conversion stops at the first null or after dmax characters.</p>
<p>Composed characters are checked for the left-hand-size of the Decomposition_Mapping Unicode property, which means the codepoint will be normalized if the sequence is composed. This is equivalent to all 1963 combining mark characters, plus some remaining 869 non-mark and non-hangul normalizables. Hangul has some special normalization logic.</p>
<p>This function is used by <code><a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a10fc468ddbb6d5e5f42c539cdcba8636" title="Converts the wide string to the canonical NFC or NFD normalization, as defined in the latest Unicode ...">wcsnorm_s()</a></code> to do the argument checking, overlap checking and to do the first of three passes for NFC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string to hold the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum result buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lenp</td><td>pointer to length of the result, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iscompat</td><td>do NFKD, and not NFD (with <code>&ndash;enable-norm-compat</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest and src shall not be null pointers. </dd>
<dd>
dmax shall not equal zero and big enough for dest. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then wcsnorm_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on success </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest or src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMIN</td><td>when dmax &lt; 5 or 19 with a compat mode </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when buffers overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax too small for the result buffer </td></tr>
    <tr><td class="paramname">EOF</td><td>on some normalization error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d47/wcsfc__s_8c.html#a692cc4f6619a725907aa0b227f443950" title="Converts the wide string via full case-folding NFD normalized to lowercase. ">wcsfc_s()</a>, <a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a10fc468ddbb6d5e5f42c539cdcba8636" title="Converts the wide string to the canonical NFC or NFD normalization, as defined in the latest Unicode ...">wcsnorm_s()</a>, <a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#ac8c8bcb822ea80a7399bebd426d9e95c" title="Combine all decomposed sequences in a wide string to NFC, as defined in the latest Unicode standard...">wcsnorm_compose_s()</a>, <a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a5b6c4b1185cf5dcb07fc0e2b4785e7c6" title="Reorder all decomposed sequences in a wide string to NFD, as defined in the latest Unicode standard...">wcsnorm_reorder_s()</a>, ICU, gnulib/libunistring, utf8proc </dd></dl>

</div>
</div>
<a id="aa90f58652f1c559c0ff9da8511983c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90f58652f1c559c0ff9da8511983c10">&#9670;&nbsp;</a></span>wcsnorm_reorder_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsnorm_reorder_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder all decomposed sequences in a wide string to NFD, as defined in the latest Unicode standard, latest 10.0. </p>
<p>The conversion stops at the first null or after dmax characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string to hold the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum result buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>wide string to be converted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest and p shall not be null pointers. </dd>
<dd>
dmax shall not equal zero and big enough for dest. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then <code>wcsnorm_reorder_s</code> nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on success </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax too small for the result buffer </td></tr>
    <tr><td class="paramname">EOF</td><td>on some normalization error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a10fc468ddbb6d5e5f42c539cdcba8636" title="Converts the wide string to the canonical NFC or NFD normalization, as defined in the latest Unicode ...">wcsnorm_s()</a>, <a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a5e12aa6178b1e2084a8c7cf89b882772" title="Converts the wide string to the canonical NFD normalization, as defined in the latest Unicode standar...">wcsnorm_decompose_s()</a>, ICU, gnulib/libunistring, utf8proc </dd></dl>

</div>
</div>
<a id="a8e80633c6c5a2ac8a07b567e0e9cb7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e80633c6c5a2ac8a07b567e0e9cb7f2">&#9670;&nbsp;</a></span>wcsnorm_compose_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsnorm_compose_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict&#160;</td>
          <td class="paramname"><em>lenp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>iscontig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine all decomposed sequences in a wide string to NFC, as defined in the latest Unicode standard, latest 10.0. </p>
<p>The conversion stops at the first null or after dmax characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string to hold the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum result buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>wide string to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lenp</td><td>pointer to length of p and the result length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iscontig</td><td>if true, the result will only be a fast FCC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest, p and lenp shall not be null pointers. </dd>
<dd>
dmax shall not equal zero and big enough for dest. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then <code>wcsnorm_reorder_s</code> nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on success </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax too small for the result buffer </td></tr>
    <tr><td class="paramname">EOF</td><td>on some normalization error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a10fc468ddbb6d5e5f42c539cdcba8636" title="Converts the wide string to the canonical NFC or NFD normalization, as defined in the latest Unicode ...">wcsnorm_s()</a>, <a class="el" href="../../d3/dd5/wcsnorm__s_8c.html#a5e12aa6178b1e2084a8c7cf89b882772" title="Converts the wide string to the canonical NFD normalization, as defined in the latest Unicode standar...">wcsnorm_decompose_s()</a>, ICU, gnulib/libunistring, utf8proc </dd></dl>

</div>
</div>
<a id="ae3de15134919337fbf0084b95961bd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3de15134919337fbf0084b95961bd7c">&#9670;&nbsp;</a></span>wcsnorm_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a77366c1bd428629dc898e188bfd182a3">EXTERN</a> errno_t wcsnorm_s </td>
          <td>(</td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a>&#160;</td>
          <td class="paramname"><em>dmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a7e951343fed5789c4ec0a61bace0b135">wcsnorm_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d0a/safe__types_8h.html#a648363f66636da630ae2caff1778b0f4">rsize_t</a> *restrict&#160;</td>
          <td class="paramname"><em>lenp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the wide string to the canonical NFC or NFD normalization, as defined in the latest Unicode standard, latest 10.0. </p>
<p>The conversion stops at the first null or after dmax characters.</p>
<p>Decomposed characters are checked for the left-hand-size and then right-hand-side of the Decomposition_Mapping Unicode property, which means the codepoint will be normalized if the sequence is composed or decomposed (NFD or NFKD). This is equivalent to all 1963 combining mark characters, plus some remaining 869 non-mark and non-hangul normalizables. Hangul has some special normalization logic.</p>
<p>The compat tables for NFKC or NFKD are too large for a libc, and mostly unused. As default we only provide the smaller canonical conversions, but it can be enabled with <code>&ndash;enable-norm-compat</code>. The compat modes also don't roundtrip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>wide string to hold the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmax</td><td>maximum length of string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>wide string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>convert to nfc or just nfd. experimentally to fast modes FCD or FCC. optionally to compat modes NFKD, NFKC with <code>&ndash;enable-norm-compat</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <code><a class="el" href="../../d8/dff/safe__str__lib_8h.html#a697d7515ad4cf3ad48348c7df8ec3a50">wcsnorm_mode</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lenp</td><td>pointer to length of the result, may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dest and src shall not be null pointers. </dd>
<dd>
dmax shall not equal zero and big enough for dest. </dd>
<dd>
dmax shall not be greater than RSIZE_MAX_WSTR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If there is a runtime-constraint violation, then if dest is not a null pointer and dmax is greater than zero and not greater than RSIZE_MAX_WSTR, then wcsnorm_s nulls dest. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EOK</td><td>on success </td></tr>
    <tr><td class="paramname">ESNULLP</td><td>when dest or src is NULL pointer </td></tr>
    <tr><td class="paramname">ESZEROL</td><td>when dmax = 0 </td></tr>
    <tr><td class="paramname">ESLEMIN</td><td>when dmax &lt; 5 </td></tr>
    <tr><td class="paramname">ESLEMAX</td><td>when dmax &gt; RSIZE_MAX_WSTR </td></tr>
    <tr><td class="paramname">ESOVRLP</td><td>when buffers overlap </td></tr>
    <tr><td class="paramname">ESNOSPC</td><td>when dmax too small for the result buffer </td></tr>
    <tr><td class="paramname">EOF</td><td>any other normalization error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d47/wcsfc__s_8c.html#a692cc4f6619a725907aa0b227f443950" title="Converts the wide string via full case-folding NFD normalized to lowercase. ">wcsfc_s()</a>, ICU, gnulib/libunistring, utf8proc </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"/><address class="footer"><small>
Generated for Safe C Library 04102017.0-gab130d-dirty 3.0
by <a href="http://www.doxygen.org/index.html">doxygen</a>
</small></address></body></html>
